var documenterSearchIndex = {"docs":
[{"location":"api/#api","page":"API Reference","title":"API Reference","text":"This page provides comprehensive documentation for all public functions in YAXArraysToolbox.jl.\n\n","category":"section"},{"location":"api/#Basic-Operations","page":"API Reference","title":"Basic Operations","text":"These are the core functions for everyday data analysis tasks.","category":"section"},{"location":"api/#Time-Series-Plotting","page":"API Reference","title":"Time Series Plotting","text":"Visualize how variables change over time by aggregating spatial dimensions.\n\nExample:\n\nplot_time(\n    cube;\n    fun = \"mean\",           # Aggregation function\n    var = \"temperature\",    # Variable to plot\n    time_axis = :time,      # Name of time dimension\n    resolution = (900, 600) # Figure size\n)\n\n","category":"section"},{"location":"api/#Spatial-Mapping","page":"API Reference","title":"Spatial Mapping","text":"Create maps by aggregating the temporal dimension.\n\nExample:\n\nplot_space(\n    cube;\n    fun = \"median\",         # Aggregation function\n    var = \"lai\",            # Variable to plot\n    time_axis = :time,      # Name of time dimension\n    resolution = (900, 600) # Figure size\n)\n\n","category":"section"},{"location":"api/#Temporal-Aggregation","page":"API Reference","title":"Temporal Aggregation","text":"Resample data to different temporal resolutions (e.g., 8-day to monthly).\n\nExample:\n\n# Aggregate from 8-day to monthly means\nmonthly_cube = aggregate_time(\n    cube;\n    new_resolution = \"month\",  # Target resolution\n    fun = \"mean\",              # Aggregation function\n    skipMissing = true         # Handle missing values\n)\n\nSupported resolutions: \"day\", \"month\", \"year\"\n\nSupported functions: \"mean\", \"median\", \"std\", \"var\", \"sum\", \"min\", \"max\", \"quant\"\n\n","category":"section"},{"location":"api/#Masking-Functions","page":"API Reference","title":"Masking Functions","text":"Functions for filtering and subsetting data based on various criteria.","category":"section"},{"location":"api/#Temporal-Masking","page":"API Reference","title":"Temporal Masking","text":"Filter data by time period.\n\nExample:\n\n# Keep only data from 2010-2015\nmasked = masking_time(\n    cube;\n    start_date = Date(2010, 1, 1),\n    end_date = Date(2015, 12, 31)\n)\n\n","category":"section"},{"location":"api/#Spatial-Masking","page":"API Reference","title":"Spatial Masking","text":"Apply spatial masks based on another data cube.\n\nExample:\n\n# Mask using a land/water mask\nmasked = masking_space(\n    data_cube,\n    land_mask_cube;\n    threshold = 0.5  # Minimum land fraction\n)\n\n","category":"section"},{"location":"api/#General-Masking","page":"API Reference","title":"General Masking","text":"Apply combined masks with multiple criteria.\n\n","category":"section"},{"location":"api/#Space-for-Time-Analysis","page":"API Reference","title":"Space-for-Time Analysis","text":"Functions for analyzing land cover change impacts using spatial variability as a proxy for temporal change.","category":"section"},{"location":"api/#Main-Processing-Function","page":"API Reference","title":"Main Processing Function","text":"Example:\n\nresults = space4time_proc(\n    climate_cube,           # Climate variable (e.g., LST)\n    landcover_cube,         # Land cover fractions\n    altitude_cube;          # Altitude data (optional)\n    classes_vec = [\"forest\", \"grassland\", \"cropland\"],\n    winsize = 5,            # Moving window size\n    showprog = true\n)\n\n","category":"section"},{"location":"api/#Spatial-Processing-Variant","page":"API Reference","title":"Spatial Processing Variant","text":"","category":"section"},{"location":"api/#Legacy-Function","page":"API Reference","title":"Legacy Function","text":"warning: Deprecated\nThis function is provided for backward compatibility. Use space4time_proc for new projects.\n\n","category":"section"},{"location":"api/#Function-Index","page":"API Reference","title":"Function Index","text":"\n\n","category":"section"},{"location":"api/#Type-Reference","page":"API Reference","title":"Type Reference","text":"All functions in YAXArraysToolbox work with YAXArray objects from YAXArrays.jl.","category":"section"},{"location":"api/#Common-Parameters","page":"API Reference","title":"Common Parameters","text":"Parameter Type Description\ncube YAXArray Input data cube\nfun String Aggregation function: \"mean\", \"median\", \"std\", \"var\", \"sum\", \"min\", \"max\", \"quant\"\ntime_axis Symbol Name of the time dimension (typically :time or :Ti)\nvar String or Nothing Variable name to process, or nothing for all\nshowprog Bool Show progress bar\nmax_cache String Maximum memory cache (e.g., \"1GB\")","category":"section"},{"location":"api/#YAXArraysToolbox.plot_time","page":"API Reference","title":"YAXArraysToolbox.plot_time","text":"Plot time\n\nThe function allow to plot the time series of a given variables in a cube or all the variables present in a cube. As is expected that cubes contain spatial dimensions the spatial dimensions are collapsed using a function e.g., estimating the mean of the variable using the pixels of a certain area for each time step.\n\n## Arguments:\n\n- ```cube_in``` YAXArray Cube.\n- ```time_axis```: String. Name of the time axis.\n- ```var_axis```: String. Name of the axis containing the variables.\n- ```var```: String or nothing. Name of the variable to be plotted. If nothing all the variables presented in the cube are plotted.\n- ```lat_axis```: String. Name of the latitude axis.\n- ```lon_axis```: String. Name of the longitute axis.\n- ```fun```: String. Name of the function used to collapse the spatial dimensions. It must be \"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", or \"max\".\n- ```plot_type```: String. Name of the plot type. By default: \"lines\". It can also be \"scatter\".\n- ```p```: Float64. in the interval [0,1]. If ```fun=quant``` p is the value of the quantile. \n- ```resolution```: Tuple. Plot resolution. By default ```resolution = (600, 400)```. \n- ```ncol```: Number of plots by column. By default ```ncol = 1```.\n- ```nrow```: Number of plots by row. By default ```ncol = 1```.\n- ```showprog```: Boolean. Progress Bar.\n- ```max_cache```: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\n\n## Examples\n\n```julia\nusing YAXArrays, Zarr, CairoMakie, GeoMakie, Statistics, DimensionalData\n\nmetric = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\n\ncube_in = open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-1x720x1440-2.1.1.zarr\",\n)\n\ncube_in = Cube(cube_in)\ncube_in.Variable\n\ncube_in = cube_in[\n    lon = (-9.0 .. 0.0),\n    lat = (35 .. 40),\n    Ti = (Date(2010) .. Date(2014)),\n    Variable = At([\"leaf_area_index\", \"sensible_heat\"]),\n]\n\n\n\nplot_time(\n    cube_in;\n    time_axis = :Ti,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = \"sensible_heat\",\n    fun = \"median\",\n    p = 0.2,\n    showprog = true,\n    max_cache = \"100MB\",\n)\n\nplot_time(\n    cube_in;\n    time_axis = :Ti,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = nothing,\n    fun = \"median\",\n    resolution = (900, 600),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"100MB\",\n    ncol = 2,\n)\n\nfor i in eachindex(metric)\n    println(metric[i])\n    plot_time(\n        cube_in;\n        time_axis = :Ti,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric[i],\n        p = 0.2,\n        showprog = true,\n        max_cache = \"100MB\",\n    )\nend\n\n```\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.plot_space","page":"API Reference","title":"YAXArraysToolbox.plot_space","text":"Plot Space/Maps\n\nArguments\n\ncube_in: YAXArray Cube.\ntime_axis: String. Name of the time axis.\nvar_axis: String. Name of the axis containing the variables.\nvar: String or nothing. Name of the variable to be plotted. If nothing all the variables presented in the cube are plotted.\nlat_axis: String. Name of the latitude axis.\nlon_axis: String. Name of the longitute axis.\nfun: String. Name of the function used to collapse the spatial dimensions. It must be \"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", or \"max\".\np: Float64. in the interval [0,1]. If fun=quant p is the value of the quantile.\ncolormap: Color Map. By default: colormap = Reverse(:batlow)\ncoastlines: Boolean. Plot coast lines. By default coastlines = false\nresolution: Plot resolution. By default resolution = (800, 300).\nxticklabel_pad: Int. X labels padding. By default xticklabel_pad = 20.\nyticklabel_pad: Int. Y labels padding. By default yticklabel_pad =20.\nncol: Number of plots by column. By default ncol = 1.\nnrow: Number of plots by row. By default ncol = 1.\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\n\nusing YAXArraysToolbox\nusing CairoMakie\nusing Statistics\nusing GeoMakie\nusing YAXArrays\nusing DimensionalData\n\n\ncube_in = open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-1x720x1440-2.1.1.zarr\",\n)\n\ncube_in = Cube(cube_in)\n\n\ncube_in = cube_in[\n    lon = (-9.0 .. 0.0),\n    lat = (35 .. 40),\n    Ti = (Date(2010) .. Date(2014)),\n    Variable = At([\"leaf_area_index\", \"sensible_heat\"]),\n]\n\nplot_space(cube_in; time_axis = :Ti, resolution = (900, 500), xticklabel_pad = 25, yticklabel_pad = 25, var_axis = :Variable, var = \"leaf_area_index\", fun = \"median\")\n\n\nmetric = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\n\nfor i in eachindex(metric)\n    println(metric[i])\n    plot_space(\n        cube_in;\n        time_axis = :Ti,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric[i],\n        p = 0.2,\n        showprog = true,\n        max_cache = \"100MB\",\n    )\nend\n\n\n\nplot_space(\n    cube_in;\n    time_axis = :Ti,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = nothing,\n    fun = \"median\",\n    resolution = (1200, 300),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"100MB\",\n    ncol = 2,\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.aggregate_time","page":"API Reference","title":"YAXArraysToolbox.aggregate_time","text":"Aggregate by time\n\nArguments:\n\ncube_in YAXArray Cube.\ntime_axis: String. Name of the time axis.\nnew_resolution: String. New temporal resolution can be \"day\", \"month\", \"year\".\nnew_time_step: Int64. Time step to be computed in the new time series. e.g. new_resolution=\"day\", new_time_step=8 will compute the function each 8 days. The new time dimension will only contain the days corresponding to the 8th day.\nfun: String. Function to be applied to aggregate the time. It can be \"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\".\np: Float64 in the interval [0,1]. If fun=quant p is the value of the quantile. \nskipMissing: Boolean. Skip missing values when aggregating the data. If all values are missing, NaN is returned.\nskipnan: Boolean. Skip NaN values when aggregating the data. If all values are NaN, NaN is returned.\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\n\nusing YAXArrays, Zarr, DimensionalData, YAXArraysToolbox\n\nesds = open_dataset(\"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\")\nesdc = Cube(esds)\n\n# Estimating the monthly LAI\n\nlai_month = aggregate_time(esdc[Variable = At(\"leaf_area_index\")]; time_axis = :Ti, new_resolution = \"month\", new_time_step=1, fun=\"mean\", p=nothing, skipMissing=true, skipnan=true, showprog=true, max_cache=\"1GB\")\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.masking_time","page":"API Reference","title":"YAXArraysToolbox.masking_time","text":"Masking using time dimension.\n\nThe function implements two methods:\n\nMasking based on a threshold value for one of the variables presented in the cube. e.g., masking the values of all the variables presented in the cube where radiation is lower than X.\nMasking based on the quantile threshold, where the quantile is estimated using the time series for each one of the variables presented in the cube.\n\nThe masked vales are set as NaN.\n\nArguments:\n\ncube_in YAXArray Cube.\ntime_axis: String. Name of the time axis.\nvar_axis: String. Name of the axis containing the variables.\nvar_mask: String or nothing. Name of the variable to be used to mask the other variables. If String val must be an Int64 or Float64 number. If nothing, val must be nothing and p must be a Float64 in the interval [0,1].\nval: Float64 or nothing. The value of the threshold in var_mask to be used to mask all the variables in the cube. If var_mask = nothing then, val=nothing\np: Float64 or nothing. Quantile value used as a threshold to mask the variables.\ncomp: String. Standard comparison operation between the threshold value and each one of the elements. comp Must be one of the following: \"==\", \"!=\" \"<\", \"<=\", \">\", \">=\".\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\nusing YAXArrays, Statistics, Zarr, NetCDF, YAXArraysToolbox\n\nesds = open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\",\n)\nesdc = Cube(esds)\n\nesdc_small = esdc[\n    lon = (-86, -35),\n    lat = (-56, 14),\n    time = (Date(2010), Date(2014)),\n    Variable = [\"leaf_area_index\", \"sensible_heat\", \"potential_evaporation\"],\n]\n\ntest = masking_time(\n    esdc_small;\n    time_axis = \"time\",\n    var_axis = \"Variable\",\n    var_mask = \"leaf_area_index\",\n    val = 0.2,\n    comp = \"<\",\n    showprog = true,\n    max_cache = \"1GB\",\n)\n\nplot_time(esdc_small; time_axis=\"time\", var_axis=\"Variable\", var = \"leaf_area_index\", lat_axis = \"lat\", lon_axis=\"lon\", fun = \"min\")\n\nplot_time(test; time_axis=\"time\", var_axis=\"Variable\", var = \"leaf_area_index\", lat_axis = \"lat\", lon_axis=\"lon\", fun = \"min\")\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.masking_space","page":"API Reference","title":"YAXArraysToolbox.masking_space","text":"Masking using spatial dimension\n\nThe masked vales are set as NaN!!.\n\nArguments:\n\ncube_in YAXArray Cube to be masked.\n\n-mask YAXArray Cube without time dimension and with a single variable to be used as mask. All values equal to NaN or missing will be masked in cubein. The mask will be applied to all the variables and time steps presented in ```cubein```.\n\nlat_axis: String. Name of the latitude axis.\nlon_axis: String. Name of the longitude axis.\nval_mask: NaN or missing. Value present in mask to be used as reference to mask cube_in. Must be NaN or missing.\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\nusing YAXArrays, Zarr, DimensionalData, Test\naxlist = (\n    Dim{:Ti}(range(1, 20, length = 20)),\n    Dim{:x}(range(1, 10, length = 10)),\n    Dim{:y}(range(1, 5, length = 15)),\n    Dim{:Variable}([\"var1\", \"var2\"]),\n    )\n    \n    \n    data = rand(20, 10, 15, 2)\n    \n    \n    ds = YAXArray(axlist, data)\n    \n    axlist = (\n    Dim{:x}(range(1, 10, length = 10)),\n    Dim{:y}(range(1, 5, length = 15)),\n    Dim{:Variable}([\"var1\"]),\n    )\n    \n    \n    data = rand(10, 15, 1)\n    \n    data[3,5,1] = NaN\n    \n    data[1,10,1] = NaN\n    \n    \n    data[9,5,1] = NaN\n    \n    ds_mask = YAXArray(axlist, data)\n    \n    \n    \n    test_cube = masking_space(ds, ds_mask; lat_axis = :x, lon_axis = :y)\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.masking_proc","page":"API Reference","title":"YAXArraysToolbox.masking_proc","text":"Masking processor\n\nArguments:\n\ncube_in_to_mask: YAXArray cube to be masked.\ncube_rsquare: Nothing, or YAXArray cube with the R^2 variable. If set to nothing no mask is applied\nrsquare_thr: Float64. R^2 threshold. All values lower than rsquare_thr are set to NaN\ncube_co_occurrence: Nothing, or YAXArray cube with the co-occurrence variable. If set to nothing no mask is applied.\nco_occurence_thr: Float64. Co-occurence threshold. All values lower than co_occurence_thr are set to NaN\ncube_delta: Nothing, or YAXArray cube with delta variable. If set to nothing no mask is applied.\nminmax_delta: Tuple. Minimum and maximum thresholds of delta variable. Values lower and higher than the thresholds are set to NaN. It is also possible to set any of the thresholds as nothing e.g. (-1, nothing) or (nothing, 1) in these cases only one threshold is applied.\ntime_dim: Nothing, or String. Name of the time dimension. This dimensions needs to be present in all the cubes. If set to nothing no time dimension considered (It can result in slower computation time!). By default time_dim = time\nshowprog: Boolean. Show progress bar. By default showprog = true\n\nOutput:\n\nYAXArray cube masked.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.space4time_proc","page":"API Reference","title":"YAXArraysToolbox.space4time_proc","text":"Space for time processor\n\nArguments:\n\ncube_con : YAXARRAY with the continous variable to be analyized.\n\ncube_classes: YAXARRAY with the discrete classes to be used in the space4time.\n\ntime_axis_name : String or nothing. Name of the time axis on the input cubes. By default time_axis_name = \"time\". if time_axis_name = nothing, not time dimension considered.\n\nlon_axis_name : String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lon\"\n\nlat_axis_name :  String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lat\"\n\nclasses_var_name : String. Name of the Variable containing the discrete classes. By default classes_var_name = \"classes\".\n\nwinsize: Edge size of the moving window on pixels. By default winsize = 5. E.g. winsize = 5 will produce a moving window with 5^2 pixels.\n\nminpxl : Minimum number of pixels in the moving window. By default minpxl = 25. Change accordindly to your winsize parameter.\n\nminDiffPxls: Minimum number pixels in the moving window that must have different compositions. Must be any value in the interval 1 to winsize^2. By default minDiffPxls = 15.\n\nclasses_vec: A string vector with the names of the classes on cube_classes to be used. e.g. from MPI-BGC internal structure classes_vec = [\"Evergreen_Needleleaf_Forests\", \"Evergreen_Broadleaf_Forests\", \"Deciduous_Needleleaf_Forests\", \"Deciduous_Broadleaf_Forests\", \"Mixed_Forests\", \"Closed_Shrublands\", \"Open_Shrublands\", \"Woody_Savannas\", \"Savannas\", \"Grasslands\", \"Permanent_Wetlands\", \"Croplands\", \"Urban_and_Built-up_Lands\", \"Cropland/Natural_Vegetation_Mosaics\", \"Permanent_Snow_and_Ice\", \"Barren\", \"Water_Bodies\"]\nmax_value: Indicates if the scale of the presence of the discrete classes if from 0 to 1 or 0 to 100 if max_value = 100 then the data is re-scaled from 0 to 1. By default max_value = 1\nshowprog: Show progress bar. By default showprog = true\nmax_cache: Size of the cache to allocate temporarily sections of the cubes. By default max_cache = 1e8\n\nOutput:\n\nThe space4time_proc produces a YAXARRAY.Dataset with three cubes:\n\nsummarymovwindow cube has one axis summary_stat, and three variables:\nrsquared:  \ncumulative_variance:\npredicted: Mean prediction of Z for moving window with the real combination of values.\nmetrics_for_classes cube has one axis Values of Z for pure classes, and two variables:\nestimated:\nestimated_error:\nmetricsfortransitions has two axis transitions (all the transitions by pairs between the different classes), and Differences with three variables:\ndelta: delta of the biophysical produced of going from one class the another.\ndelta_error:\ncoocurence:\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.space4time_proc_space","page":"API Reference","title":"YAXArraysToolbox.space4time_proc_space","text":"Space for time processor (space chunks)\n\nArguments:\n\ncube_con : YAXARRAY with the continous variable to be analyized.\n\ncube_classes: YAXARRAY with the discrete classes to be used in the space4time.\n\ntime_axis_name : String or nothing. Name of the time axis on the input cubes. By default time_axis_name = \"time\". if time_axis_name = nothing, not time dimension considered.\n\nlon_axis_name : String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lon\"\n\nlat_axis_name :  String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lat\"\n\nclasses_var_name : String. Name of the Variable containing the discrete classes. By default classes_var_name = \"classes\".\n\nwinsize: Edge size of the moving window on pixels. By default winsize = 5. E.g. winsize = 5 will produce a moving window with 5^2 pixels.\n\nminpxl : Minimum number of pixels in the moving window. By default minpxl = 25. Change accordindly to your winsize parameter.\n\nminDiffPxlspercentage: Percentage of minimum number pixels in the moving window that must have different compositions. Must be any value in the interval 30-100. By default minDiffPxlspercentage = 40\n\nclasses_vec: A string vector with the names of the classes on cube_classes to be used. e.g. from MPI-BGC internal structure classes_vec = [\"Evergreen_Needleleaf_Forests\", \"Evergreen_Broadleaf_Forests\", \"Deciduous_Needleleaf_Forests\", \"Deciduous_Broadleaf_Forests\", \"Mixed_Forests\", \"Closed_Shrublands\", \"Open_Shrublands\", \"Woody_Savannas\", \"Savannas\", \"Grasslands\", \"Permanent_Wetlands\", \"Croplands\", \"Urban_and_Built-up_Lands\", \"Cropland/Natural_Vegetation_Mosaics\", \"Permanent_Snow_and_Ice\", \"Barren\", \"Water_Bodies\"]\nmax_value: Indicates if the scale of the presence of the discrete classes if from 0 to 1 or 0 to 100 if max_value = 100 then the data is re-scaled from 0 to 1. By default max_value = 1\nshowprog: Show progress bar. By default showprog = true\nmax_cache: Size of the cache to allocate temporarily sections of the cubes. By default max_cache = 1e8\n\nOutput:\n\nThe space4time_proc produces a YAXARRAY.Dataset with three cubes:\n\nSummaryStats cube has one axis summary_stat, and three variables:\nrsquared:  \ncumulative_variance:\npredicted:\nmetrics_for_classes cube has one axis Values of Z for pure classes, and two variables:\nestimated:\nestimated_error:\nmetricsfortransitions has two axis transitions (all the transitions by pairs between the different classes), and Differences with three variables:\ndelta:\ndelta_error:\ncoocurence:\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.space4time_proc_old","page":"API Reference","title":"YAXArraysToolbox.space4time_proc_old","text":"Space for time processor\n\nArguments:\n\ncube_con : YAXARRAY with the continous variable to be analyized.\n\ncube_classes: YAXARRAY with the discrete classes to be used in the space4time.\n\ntime_axis_name : String or nothing. Name of the time axis on the input cubes. By default time_axis_name = \"time\". if time_axis_name = nothing, not time dimension considered.\n\nlon_axis_name : String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lon\"\n\nlat_axis_name :  String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lat\"\n\nclasses_var_name : String. Name of the Variable containing the discrete classes. By default classes_var_name = \"classes\".\n\nwinsize: Edge size of the moving window on pixels. By default winsize = 5. E.g. winsize = 5 will produce a moving window with 5^2 pixels.\n\nminpxl : Minimum number of pixels in the moving window. By default minpxl = 25. Change accordindly to your winsize parameter.\n\nminDiffPxlspercentage: Percentage of minimum number pixels in the moving window that must have different compositions. Must be any value in the interval 30-100. By default minDiffPxlspercentage = 40\n\nclasses_vec: A string vector with the names of the classes on cube_classes to be used. e.g. from MPI-BGC internal structure classes_vec = [\"Evergreen_Needleleaf_Forests\", \"Evergreen_Broadleaf_Forests\", \"Deciduous_Needleleaf_Forests\", \"Deciduous_Broadleaf_Forests\", \"Mixed_Forests\", \"Closed_Shrublands\", \"Open_Shrublands\", \"Woody_Savannas\", \"Savannas\", \"Grasslands\", \"Permanent_Wetlands\", \"Croplands\", \"Urban_and_Built-up_Lands\", \"Cropland/Natural_Vegetation_Mosaics\", \"Permanent_Snow_and_Ice\", \"Barren\", \"Water_Bodies\"]\nmax_value: Indicates if the scale of the presence of the discrete classes if from 0 to 1 or 0 to 100 if max_value = 100 then the data is re-scaled from 0 to 1. By default max_value = 1\nshowprog: Show progress bar. By default showprog = true\nmax_cache: Size of the cache to allocate temporarily sections of the cubes. By default max_cache = 1e8\n\nOutput:\n\nThe space4time_proc produces a YAXARRAY.Dataset with three cubes:\n\nSummaryStats cube has one axis summary_stat, and three variables:\nrsquared:  \ncumulative_variance:\npredicted: Mean prediction of Z for moving window with the real combination of values.\nmetrics_for_classes cube has one axis Values of Z for pure classes, and two variables:\nestimated:\nestimated_error:\nmetricsfortransitions has two axis transitions (all the transitions by pairs between the different classes), and Differences with three variables:\ndelta: delta of the biophysical produced of going from one class the another.\ndelta_error:\ncoocurence:\n\n\n\n\n\n\n\n","category":"function"},{"location":"tutorials/basic_operations/#basic_operations","page":"Basic Operations","title":"Basic Operations","text":"<div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2em; border-radius: 8px; margin-bottom: 2em;\">\n  <h2 style=\"margin: 0; color: white;\">üìä Getting Started with YAXArraysToolbox.jl</h2>\n  <p style=\"margin: 0.5em 0 0 0; opacity: 0.9;\">Learn the core functions for visualizing and processing Earth System data cubes</p>\n</div>\n\nAuthor: Daniel E. Pabon-Moreno\n\n","category":"section"},{"location":"tutorials/basic_operations/#What-You'll-Learn","page":"Basic Operations","title":"What You'll Learn","text":"In this tutorial, you will learn how to:\n\n‚úÖ Load data from the Earth System Data Cube (ESDC)\n‚úÖ Create time series plots with plot_time\n‚úÖ Generate spatial maps with plot_space\n‚úÖ Aggregate data to different temporal resolutions with aggregate_time\n\ntip: Prerequisites\nBasic familiarity with Julia and the concept of multi-dimensional arrays is helpful but not required.\n\n","category":"section"},{"location":"tutorials/basic_operations/#Setup","page":"Basic Operations","title":"Setup","text":"First, let's load all the required packages:\n\nusing Pkg\nPkg.instantiate()\nusing YAXArrays\nPkg.add(url=\"https://github.com/dpabon/YAXArraysToolbox.jl\")\nusing YAXArraysToolbox\nusing CairoMakie\nusing GeoMakie\nusing Statistics\nusing Zarr\nusing Dates\nusing PythonCall\nusing DimensionalData\n\n","category":"section"},{"location":"tutorials/basic_operations/#Loading-Data","page":"Basic Operations","title":"Loading Data","text":"We'll use the Earth System Data Cube (ESDC), an analysis-ready data cube containing dozens of climate and Earth observation variables at global scale.\n\nesdc = open_dataset(\"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\")\nesdc = Cube(esdc)\nesdc\n\ninfo: About the ESDC\nThe Earth System Data Cube provides harmonized Earth observation and climate data at 0.25¬∞ spatial resolution and 8-day temporal resolution, spanning from 1979 to 2021.\n\n","category":"section"},{"location":"tutorials/basic_operations/#1.-Time-Series-Plotting-with-plot_time","page":"Basic Operations","title":"1. Time Series Plotting with plot_time","text":"The plot_time function creates time series plots by collapsing spatial dimensions using a specified statistic (mean, median, std, etc.).","category":"section"},{"location":"tutorials/basic_operations/#Selecting-a-Region","page":"Basic Operations","title":"Selecting a Region","text":"Let's focus on South America and select a time period:\n\ncube_to_plot = esdc[\n    lon = -86 .. -35,\n    lat = -56 .. 14,\n    time = Date(2010) .. Date(2014),\n    Variable = At(\"leaf_area_index\", \"sensible_heat\"),\n]\ncube_to_plot","category":"section"},{"location":"tutorials/basic_operations/#Plotting-All-Variables","page":"Basic Operations","title":"Plotting All Variables","text":"By default, plot_time plots all variables in the cube:\n\nplot_time(\n    cube_to_plot;\n    time_axis = :time,\n    var_axis = :Variables,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = nothing,\n    fun = \"std\",\n    resolution = (900, 600),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"1GB\",\n    ncol = 1,\n    nrow = 2\n)","category":"section"},{"location":"tutorials/basic_operations/#Plotting-a-Single-Variable","page":"Basic Operations","title":"Plotting a Single Variable","text":"You can also target a specific variable:\n\nplot_time(\n    cube_to_plot;\n    time_axis = :time,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = \"sensible_heat\",\n    fun = \"std\",\n    resolution = (900, 600),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"1GB\",\n    ncol = 1,\n    nrow = 2\n)","category":"section"},{"location":"tutorials/basic_operations/#Available-Statistics","page":"Basic Operations","title":"Available Statistics","text":"The fun parameter supports multiple aggregation statistics:\n\nStatistic Description\n\"mean\" Arithmetic mean\n\"median\" Median (50th percentile)\n\"std\" Standard deviation\n\"var\" Variance\n\"sum\" Sum of values\n\"min\" Minimum value\n\"max\" Maximum value\n\"quant\" Quantile (requires p parameter)\n\nmetrics = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\nfor metric in metrics\n    fig = plot_time(\n        cube_to_plot;\n        time_axis = :time,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric,\n        resolution = (900, 600),\n        p = 0.2,\n        showprog = true,\n        max_cache = \"1GB\",\n        ncol = 1,\n        nrow = 2\n    )\n    display(fig)\nend\n\n","category":"section"},{"location":"tutorials/basic_operations/#2.-Spatial-Mapping-with-plot_space","page":"Basic Operations","title":"2. Spatial Mapping with plot_space","text":"The plot_space function creates spatial maps by collapsing the time dimension.","category":"section"},{"location":"tutorials/basic_operations/#Single-Variable-Map","page":"Basic Operations","title":"Single Variable Map","text":"cube_to_plot = esdc[\n    lon = -86 .. -34,\n    lat = -56 .. 14,\n    time = Date(2010) .. Date(2014),\n    Variable = At(\"leaf_area_index\", \"sensible_heat\"),\n]\n\nplot_space(\n    cube_to_plot;\n    time_axis = :time,\n    resolution = (900, 600),\n    var_axis = :Variable,\n    var = \"leaf_area_index\",\n    fun = \"median\"\n)","category":"section"},{"location":"tutorials/basic_operations/#Multiple-Variables-Side-by-Side","page":"Basic Operations","title":"Multiple Variables Side by Side","text":"Set var = nothing to plot all variables:\n\nplot_space(\n    cube_to_plot;\n    time_axis = :time,\n    resolution = (900, 600),\n    var_axis = :Variables,\n    var = nothing,\n    ncol = 2,\n    nrow = 1,\n    fun = \"median\"\n)","category":"section"},{"location":"tutorials/basic_operations/#Comparing-Different-Statistics","page":"Basic Operations","title":"Comparing Different Statistics","text":"metrics = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\nfor metric in metrics\n    fig = plot_space(\n        cube_to_plot;\n        time_axis = :time,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric,\n        p = 0.2,\n        showprog = true,\n        max_cache = \"100MB\"\n    )\n    display(fig)\nend\n\n","category":"section"},{"location":"tutorials/basic_operations/#3.-Temporal-Aggregation-with-aggregate_time","page":"Basic Operations","title":"3. Temporal Aggregation with aggregate_time","text":"The aggregate_time function allows you to resample data to different temporal resolutions.","category":"section"},{"location":"tutorials/basic_operations/#Monthly-Aggregation-Example","page":"Basic Operations","title":"Monthly Aggregation Example","text":"The ESDC has 8-day temporal resolution. Let's aggregate to monthly means:\n\nlai_month = aggregate_time(\n    esdc[Variable = At(\"leaf_area_index\")];\n    time_axis = :time,\n    new_resolution = \"month\",\n    new_time_step = 1,\n    fun = \"mean\",\n    p = nothing,\n    skipMissing = true,\n    skipnan = true,\n    showprog = true,\n    max_cache = \"1GB\"\n)\nlai_month","category":"section"},{"location":"tutorials/basic_operations/#Checking-the-Result","page":"Basic Operations","title":"Checking the Result","text":"Let's verify the new time axis:\n\nlookup(lai_month, :Ti)\n\nsuccess: Result\nThe original 8-day temporal resolution has been aggregated to monthly values. The time axis now contains approximately 480 values (one per month over the full time range) instead of the original ~1800+ 8-day values.\n\n","category":"section"},{"location":"tutorials/basic_operations/#Quick-Reference","page":"Basic Operations","title":"Quick Reference","text":"Function Purpose Key Parameters\nplot_time Time series plot fun, var, time_axis\nplot_space Spatial map fun, var, time_axis\naggregate_time Temporal aggregation new_resolution, fun","category":"section"},{"location":"tutorials/basic_operations/#Common-Parameters","page":"Basic Operations","title":"Common Parameters","text":"fun = \"mean\"           # Aggregation statistic\nvar = \"temperature\"    # Variable name (or nothing for all)\ntime_axis = :time      # Name of time dimension\nshowprog = true        # Show progress bar\nmax_cache = \"1GB\"      # Memory limit for caching\n\n","category":"section"},{"location":"tutorials/basic_operations/#Next-Steps","page":"Basic Operations","title":"Next Steps","text":"Now that you've mastered the basics, explore more advanced analysis:\n\nüìñ Space-for-Time Method ‚Äî Learn how to estimate land cover change impacts\nüìö API Reference ‚Äî Complete documentation of all functions\n\n\n\n<div style=\"background: #f0f7ff; border-left: 4px solid #3b82f6; padding: 1em; margin-top: 2em;\">\n  <strong>üí° Tip:</strong> All examples in this tutorial use lazy evaluation. Data is only loaded when needed, making it efficient to work with large datasets.\n</div>","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#space4time","page":"Space-for-Time Method","title":"Space-for-Time Method","text":"<div style=\"background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 2em; border-radius: 8px; margin-bottom: 2em;\">\n  <h2 style=\"margin: 0; color: white;\">üåç Proof of Concept: Space-for-Time Analysis</h2>\n  <p style=\"margin: 0.5em 0 0 0; opacity: 0.9;\">Estimate land cover change impacts using spatial variability</p>\n</div>\n\nAuthor: Daniel E. Pabon-Moreno\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Overview","page":"Space-for-Time Method","title":"Overview","text":"Land use changes have significant consequences on the Earth system's energy budget. For example, deforestation of tropical rainforests profoundly impacts carbon and water cycles at local, regional, and global scales.\n\nThe space-for-time method uses local vegetation contrasts to disentangle the effects of land use changes on biophysical variables like Land Surface Temperature (LST).\n\ninfo: What You'll Learn\nThe theoretical basis of the space-for-time method\nHow to generate synthetic test data\nHow to run and interpret space4time_proc results\nHow to filter results using R¬≤ and co-occurrence thresholds\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Setup","page":"Space-for-Time Method","title":"Setup","text":"using Pkg\nPkg.add(url=\"https://github.com/JuliaStats/GLM.jl\", rev=\"f4047d4930957bc5317fd4d0b73f197383a4ee4a\")\nPkg.add(url = \"https://github.com/dpabon/YAXArraysToolbox.jl\")\nusing SkipNan\nusing YAXArraysToolbox\nusing YAXArrays\nusing Zarr\nusing CairoMakie\nusing GeoMakie\nusing Random\nusing NeutralLandscapes\nusing TiledViews\nusing DimensionalData\nusing Statistics\n\n# Set temporary directory for YAXArrays\nYAXArrays.YAXdir(\"/tmp/YAXA_tmp\")\n\n# Activate CairoMakie for plotting\nCairoMakie.activate!()\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#The-Space-for-Time-Method","page":"Space-for-Time Method","title":"The Space-for-Time Method","text":"","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Conceptual-Framework","page":"Space-for-Time Method","title":"Conceptual Framework","text":"The space-for-time method is based on a key assumption: spatial variability in land cover within a local area can serve as a proxy for temporal changes in land cover.\n\n<div style=\"background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 1.5em; margin: 1.5em 0;\">\n  <h4 style=\"margin-top: 0;\">üîë Key Insight</h4>\n  <p>If we observe how Land Surface Temperature varies across different land cover types <em>within a small moving window</em>, we can estimate the temperature change that would occur if the land cover <em>changed over time</em>.</p>\n</div>","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Algorithm-Steps","page":"Space-for-Time Method","title":"Algorithm Steps","text":"The method follows these steps:\n\nDefine a moving window over the study area\nWithin each window, analyze the relationship between land cover composition and the target variable\nUse regression to estimate the contribution of each land cover type\nCalculate transition effects when converting between land cover types\n\nflowchart TD\n    A[Land Cover Map] --> B[Moving Window]\n    C[Biophysical Variable] --> B\n    B --> D[Local Regression]\n    D --> E[Land Cover Coefficients]\n    E --> F[Transition Effects]\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Generating-Synthetic-Data","page":"Space-for-Time Method","title":"Generating Synthetic Data","text":"To demonstrate the method, we'll create synthetic land cover and temperature data with known properties.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Step-1:-Create-a-Land-Cover-Map","page":"Space-for-Time Method","title":"Step 1: Create a Land Cover Map","text":"We'll generate a 1000 √ó 1000 pixel land cover map (1 pixel = 1 meter, so 1 km √ó 1 km total):\n\nedge = 1000\nsize_tile = (edge, edge)\n\nGenerate a spatially autocorrelated pattern using midpoint displacement:\n\nRandom.seed!(232323)\nspatial_auto = 0.9\nmidpoint_sim = rand(MidpointDisplacement(spatial_auto), size_tile)\nheatmap(midpoint_sim)\n\nClassify into 3 land cover classes:\n\nn_classes = 3\nclasses_dist = NeutralLandscapes.classify(midpoint_sim, ones(n_classes))\n\nheatmap(classes_dist)","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Step-2:-Assign-LST-Values-per-Class","page":"Space-for-Time Method","title":"Step 2: Assign LST Values per Class","text":"We define a constant Land Surface Temperature (LST) for each class:\n\n# LST values per class (¬∞C)\nclass_1_lst = 20.0  # e.g., Forest (coolest)\nclass_2_lst = 22.0  # e.g., Grassland\nclass_3_lst = 23.8  # e.g., Cropland (warmest)\n\nall_lst = (class_1_lst, class_2_lst, class_3_lst)\n\n# Create LST map\nlst = fill(NaN, size_tile)\n\nfor i in eachindex(all_lst)\n    lst[findall(==(i), classes_dist)] .= all_lst[i]\nend","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Step-3:-Add-Altitude-as-a-Confounding-Factor","page":"Space-for-Time Method","title":"Step 3: Add Altitude as a Confounding Factor","text":"In reality, altitude affects LST. Let's add this confounding factor:\n\nRandom.seed!(87)\nspatial_auto = 0.9\nmidpoint_sim = rand(MidpointDisplacement(spatial_auto), size_tile)\nheatmap(midpoint_sim)\n\naltitude = midpoint_sim * 1000  # Scale to 0-1000 meters\naltitude\n\nApply the adiabatic lapse rate (9.8¬∞C per 1000 meters):\n\nheatmap(lst)\n\nlst_altitude_corrected = lst .- (altitude .* 9.8 / 1000)\nheatmap(lst_altitude_corrected)\n\nVerify the altitude-LST relationship:\n\nscatter(vec(altitude), vec(lst_altitude_corrected))\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Spatial-Resampling","page":"Space-for-Time Method","title":"Spatial Resampling","text":"Land cover maps typically have coarser resolution than 1 meter. We'll aggregate to a new spatial resolution and estimate the frequency of each class per pixel.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Resample-Land-Cover-Classes","page":"Space-for-Time Method","title":"Resample Land Cover Classes","text":"size_pixel_new = 20  # New pixel size: 20√ó20 = 400 original pixels\n\n# Use TiledView to create views of each new pixel\na = TiledView(classes_dist, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false, pad_value = NaN32)\n\n# Array for resampled class frequencies\nnew_res_array_classes = fill(0.0, (size_pixel_new, size_pixel_new, n_classes))\n\nfor i in 1:size_pixel_new\n    for j in 1:size_pixel_new\n        for c in 1:n_classes\n            new_res_array_classes[i, j, c] = count(==(c), a[:, :, i, j]) / (size_pixel_new^2)\n        end\n    end\nend\n\nVisualize the class frequencies:\n\nClass 1:\n\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Class 1 Frequency\")\ntemp = heatmap!(new_res_array_classes[:, :, 1], colormap = Reverse(:bamako))\nColorbar(fig[1, 2], temp, label = \"Occurrence\")\nfig\n\nClass 2:\n\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Class 2 Frequency\")\ntemp = heatmap!(new_res_array_classes[:, :, 2], colormap = Reverse(:bamako))\nColorbar(fig[1, 2], temp, label = \"Occurrence\")\nfig\n\nClass 3:\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Class 3 Frequency\")\ntemp = heatmap!(new_res_array_classes[:, :, 3], colormap = Reverse(:bamako))\nColorbar(fig[1, 2], temp, label = \"Occurrence\")\nfig","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Resample-Altitude","page":"Space-for-Time Method","title":"Resample Altitude","text":"For altitude, we'll create both mean and standard deviation:\n\na = TiledView(altitude, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false)\n\nnew_res_array_altitude = fill(NaN, (size_pixel_new, size_pixel_new, 2))\n\nfor i in 1:size_pixel_new\n    for j in 1:size_pixel_new\n        new_res_array_altitude[i, j, 1] = mean(a[:, :, i, j])\n        new_res_array_altitude[i, j, 2] = std(a[:, :, i, j])\n    end\nend\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Mean Altitude\")\ntemp = heatmap!(new_res_array_altitude[:, :, 1], colormap = :lajolla)\nColorbar(fig[1, 2], temp, label = \"Altitude (m)\")\nfig\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Altitude Std Dev\")\ntemp = heatmap!(new_res_array_altitude[:, :, 2], colormap = :lajolla)\nColorbar(fig[1, 2], temp, label = \"Altitude (m)\")\nfig","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Resample-LST","page":"Space-for-Time Method","title":"Resample LST","text":"a = TiledView(lst_altitude_corrected, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false)\n\nnew_res_array_lst = fill(NaN, (size_pixel_new, size_pixel_new))\n\nfor i in 1:size_pixel_new\n    for j in 1:size_pixel_new\n        new_res_array_lst[i, j] = mean(a[:, :, i, j])\n    end\nend\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Mean LST\")\ntemp = heatmap!(new_res_array_lst[:, :], colormap = :lajolla)\nColorbar(fig[1, 2], temp, label = \"LST (¬∞C)\")\nfig\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Organizing-Data-as-YAXArrays","page":"Space-for-Time Method","title":"Organizing Data as YAXArrays","text":"","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Land-Cover-Cube","page":"Space-for-Time Method","title":"Land Cover Cube","text":"axlist = (\n    lon(1:size(new_res_array_classes, 1)),\n    lat(1:size(new_res_array_classes, 2)),\n    Variables([\"class$i\" for i in 1:n_classes])\n)\n\nlcc_cube = YAXArray(axlist, new_res_array_classes)\nlcc_cube","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Altitude-Cube","page":"Space-for-Time Method","title":"Altitude Cube","text":"axlist = (\n    lon(1:size(new_res_array_classes, 1)),\n    lat(1:size(new_res_array_classes, 2)),\n    Variables([\"altitude_mean\", \"altitude_sd\"])\n)\n\naltitude_cube = YAXArray(axlist, new_res_array_altitude)","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#LST-Cube","page":"Space-for-Time Method","title":"LST Cube","text":"axlist_lst = (\n    lon(1:size(new_res_array_lst, 1)),\n    lat(1:size(new_res_array_lst, 2))\n)\n\nlst_cube = YAXArray(axlist_lst, new_res_array_lst)\nlst_cube\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Running-Space4Time-Analysis","page":"Space-for-Time Method","title":"Running Space4Time Analysis","text":"Now we can use the space4time_proc function:\n\nresults = space4time_proc(\n    lst_cube,\n    lcc_cube,\n    altitude_cube;\n    time_axis_name = nothing,\n    altitude_var_name = :Variables,\n    altitude_vec = [\"altitude_mean\", \"altitude_sd\"],\n    classes_var_name = :Variables,\n    classes_vec = [\"class1\", \"class2\", \"class3\"],\n    winsize = 5,\n    minpxl = 0,\n    minDiffPxls = 0,\n    max_value = 1,\n    showprog = true\n)\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Interpreting-Results","page":"Space-for-Time Method","title":"Interpreting Results","text":"The space4time analysis returns several outputs:\n\nOutput Description\ncoefficients Estimated effect of each land cover class\nR¬≤ Goodness of fit for each moving window\ntransition effects Expected change when converting between classes","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Expected-Results","page":"Space-for-Time Method","title":"Expected Results","text":"Given our synthetic data with known LST values:\n\nTransition Expected ŒîT (¬∞C) Interpretation\nClass 1 ‚Üí Class 2 +2.0 Forest ‚Üí Grassland warming\nClass 1 ‚Üí Class 3 +3.8 Forest ‚Üí Cropland warming\nClass 2 ‚Üí Class 3 +1.8 Grassland ‚Üí Cropland warming\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Filtering-Results","page":"Space-for-Time Method","title":"Filtering Results","text":"","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Using-R-and-Co-occurrence-Thresholds","page":"Space-for-Time Method","title":"Using R¬≤ and Co-occurrence Thresholds","text":"metrics_transitions_cube = results.metrics_for_transitions\n\nmetrics_transitions_cube[differences = At(\"delta\")].data\n\nApply quality filters:\n\nmasking_without_delta = masking_proc(\n    results.metrics_for_transitions;\n    cube_rsquared = results.summary_mov_window[summary_stat = At(\"rsquared_adjusted\")],\n    rsquared_thr = 0.2,\n    cube_co_occurrence = results.metrics_for_transitions[Differences = At(\"coocurence\")],\n    co_occurence_thr = 0.5,\n    cube_delta = nothing,\n    time_dim = nothing,\n    showprog = true\n)\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Plotting-Results","page":"Space-for-Time Method","title":"Plotting Results","text":"Compare the estimated deltas with the original (known) values:\n\ndelta_1_org = abs(class_1_lst - class_2_lst)\ndelta_2_org = abs(class_1_lst - class_3_lst)\ndelta_3_org = abs(class_2_lst - class_3_lst)\n\nvec_delta_orig = Array{Float64}(reshape(\n    results.metrics_for_transitions[differences = At(\"delta\")].data,\n    (size_pixel_new^2 * n_classes)\n))\n\nvec_delta_plot = vec_delta_orig[findall(!isnan, vec_delta_orig)]\n\nvec_index = repeat(1:n_classes, outer = (size_pixel_new^2 * n_classes))\nvec_index = vec_index[findall(!isnan, vec_delta_orig)]\n\ntransitions = lookup(masking_without_delta, :transitions)\nfig = Figure()\nax = Axis(fig[1,1], xticks = (1:length(transitions), transitions))\ntemp = scatter!(ax, vec_index, vec_delta_plot)\ntemp2 = scatter!(ax, [i + 0.1 for i in 1:n_classes], \n    [delta_1_org, delta_2_org, delta_3_org], \n    marker = :diamond, color = :red, markersize = 15)\nLegend(fig[1, 2],\n    [temp, temp2],\n    [\"Space4time Results\", \"Original Delta\"])\nfig\n\nsuccess: Validation\nThe space4time method successfully recovers the known temperature differences between land cover classes, demonstrating the validity of the approach.\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Summary","page":"Space-for-Time Method","title":"Summary","text":"<div style=\"background: #e7f5e7; border: 1px solid #28a745; border-radius: 8px; padding: 1.5em; margin: 1.5em 0;\">\n  <h4 style=\"margin-top: 0; color: #155724;\">‚úÖ Key Takeaways</h4>\n  <ul style=\"margin-bottom: 0;\">\n    <li>The space-for-time method estimates land cover change impacts without long time series</li>\n    <li>Spatial variability within moving windows serves as a proxy for temporal change</li>\n    <li>Quality filtering using R¬≤ and co-occurrence improves result reliability</li>\n    <li>The method can quantify biophysical effects of land use transitions</li>\n  </ul>\n</div>\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#References","page":"Space-for-Time Method","title":"References","text":"Duveiller, Gregory, Josh Hooker, and Alessandro Cescatti. \"A Dataset Mapping the Potential Biophysical Effects of Vegetation Cover Change.\" Scientific Data 5, no. 1 (2018): 1. https://doi.org/10.1038/sdata.2018.14\nLi, Yan, Maosheng Zhao, Safa Motesharrei, Qiaozhen Mu, Eugenia Kalnay, and Shuangcheng Li. \"Local Cooling and Warming Effects of Forests Based on Satellite Observations.\" Nature Communications 6, no. 1 (2015): 6603. https://doi.org/10.1038/ncomms7603\n\n","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Next-Steps","page":"Space-for-Time Method","title":"Next Steps","text":"üìñ Return to Basic Operations for core function usage\nüìö See the API Reference for complete function documentation","category":"section"},{"location":"#YAXArraysToolbox.jl","page":"Home","title":"YAXArraysToolbox.jl","text":"High-performance spatio-temporal analysis for Earth System data cubes\n\n\n\nYAXArraysToolbox.jl extends YAXArrays.jl with high-level functions for analyzing spatio-temporal data cubes from climate science and Earth observation.\n\ntip: Why YAXArraysToolbox?\nBecause laziness is not only good when reading big data ‚Äî it should also apply to common analysis tasks! This package provides ready-to-use functions for plotting, aggregation, and analysis so you can focus on science, not boilerplate code.\n\n","category":"section"},{"location":"#Features-at-a-Glance","page":"Home","title":"‚ú® Features at a Glance","text":"YAXArraysToolbox extends YAXArrays.jl with high-level functions for climate and Earth observation data analysis:\n\nFeature Description\nüìà Time Series Plotting Visualize temporal evolution with automatic spatial aggregation\nüó∫Ô∏è Spatial Mapping Create publication-ready maps with temporal aggregation\n‚è±Ô∏è Temporal Aggregation Resample data to monthly, yearly, or custom periods\nüîÑ Space-for-Time Analysis Estimate land cover change impacts on climate variables\nüò∑ Flexible Masking Apply spatial, temporal, and altitude-based masks","category":"section"},{"location":"#Installation","page":"Home","title":"üì¶ Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/dpabon/YAXArraysToolbox.jl\")\n\nOr using the package manager:\n\njulia> ]\npkg> add https://github.com/dpabon/YAXArraysToolbox.jl","category":"section"},{"location":"#Quick-Start","page":"Home","title":"üöÄ Quick Start","text":"using YAXArraysToolbox\nusing YAXArrays\nusing CairoMakie\nusing Dates\n\n# Load Earth System Data Cube\nesdc = Cube(open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\"\n))\n\n# Select a region and variable\ncube = esdc[\n    lon = -10 .. 0,\n    lat = 35 .. 45,\n    time = Date(2010) .. Date(2012),\n    Variable = At(\"leaf_area_index\")\n]\n\n# Plot time series (spatial mean)\nplot_time(cube; fun=\"mean\")\n\n# Create spatial map (temporal median)\nplot_space(cube; fun=\"median\")\n\n# Aggregate to monthly resolution\nmonthly = aggregate_time(cube; new_resolution=\"month\", fun=\"mean\")","category":"section"},{"location":"#Tutorials","page":"Home","title":"üìö Tutorials","text":"Get hands-on experience with our step-by-step tutorials:\n\n<div style=\"display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1em; margin: 2em 0;\">\n  <div style=\"border: 1px solid #ddd; border-radius: 8px; padding: 1.5em; background: #f9f9f9;\">\n    <h3 style=\"margin-top: 0;\">üìä Basic Operations</h3>\n    <p>Learn the core functions: <code>plot_time</code>, <code>plot_space</code>, and <code>aggregate_time</code>.</p>\n    <a href=\"tutorials/basic_operations/\">Start Tutorial ‚Üí</a>\n  </div>\n  <div style=\"border: 1px solid #ddd; border-radius: 8px; padding: 1.5em; background: #f9f9f9;\">\n    <h3 style=\"margin-top: 0;\">üåç Space-for-Time Method</h3>\n    <p>Understand and apply the space4time methodology for land cover change analysis.</p>\n    <a href=\"tutorials/space4time_proof_of_concept/\">Start Tutorial ‚Üí</a>\n  </div>\n</div>","category":"section"},{"location":"#Tutorial-Overview","page":"Home","title":"Tutorial Overview","text":"Basic Operations ‚Äî Essential functions for data visualization and aggregation\nSpace-for-Time Method ‚Äî Advanced methodology for estimating land cover change impacts","category":"section"},{"location":"#Package-Architecture","page":"Home","title":"üèóÔ∏è Package Architecture","text":"YAXArraysToolbox\n‚îú‚îÄ‚îÄ Basic Operations\n‚îÇ   ‚îú‚îÄ‚îÄ plot_time      ‚Üí Time series visualization\n‚îÇ   ‚îú‚îÄ‚îÄ plot_space     ‚Üí Spatial mapping\n‚îÇ   ‚îî‚îÄ‚îÄ aggregate_time ‚Üí Temporal resampling\n‚îú‚îÄ‚îÄ Masking\n‚îÇ   ‚îú‚îÄ‚îÄ masking_time     ‚Üí Filter by time period\n‚îÇ   ‚îú‚îÄ‚îÄ masking_space    ‚Üí Spatial filtering\n‚îÇ   ‚îî‚îÄ‚îÄ masking_altitude ‚Üí Elevation-based filtering\n‚îî‚îÄ‚îÄ Spatio-Temporal Analysis\n    ‚îî‚îÄ‚îÄ space4time_proc  ‚Üí Land cover change impact analysis","category":"section"},{"location":"#Main-Functions","page":"Home","title":"üîß Main Functions","text":"","category":"section"},{"location":"#Basic-Operations","page":"Home","title":"Basic Operations","text":"# Time series visualization with spatial aggregation\nplot_time(cube; fun=\"mean\", var=\"temperature\")\n\n# Spatial mapping with temporal aggregation\nplot_space(cube; fun=\"median\", var=\"lai\")\n\n# Temporal aggregation/resampling\naggregate_time(cube; new_resolution=\"month\", fun=\"mean\")","category":"section"},{"location":"#Masking","page":"Home","title":"Masking","text":"# Mask by spatial extent\nmasking_space(cube, mask_cube; threshold=0.5)\n\n# Mask by time period\nmasking_time(cube; start_date=Date(2010), end_date=Date(2015))","category":"section"},{"location":"#Spatio-Temporal-Analysis","page":"Home","title":"Spatio-Temporal Analysis","text":"# Space-for-time analysis for land cover change impacts\nspace4time_proc(climate_cube, landcover_cube, class_list)","category":"section"},{"location":"#Dependencies","page":"Home","title":"üìñ Dependencies","text":"YAXArraysToolbox builds on these excellent Julia packages:\n\nPackage Purpose\nYAXArrays.jl Data cube handling and lazy operations\nCairoMakie.jl High-quality plotting\nGeoMakie.jl Geographic projections and mapping","category":"section"},{"location":"#Contributing","page":"Home","title":"ü§ù Contributing","text":"Contributions are welcome! Here's how you can help:\n\nReport bugs ‚Äî Open an issue describing the problem\nSuggest features ‚Äî Share your ideas in the issues section\nSubmit PRs ‚Äî Fork the repo and submit pull requests\n\nPlease check existing issues before creating new ones.","category":"section"},{"location":"#Citation","page":"Home","title":"üìÑ Citation","text":"If you use YAXArraysToolbox in your research, please cite:\n\n(Image: DOI)","category":"section"},{"location":"#License","page":"Home","title":"üìú License","text":"MIT License","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"üôè Acknowledgements","text":"This project was funded by:\n\nOpen-Earth-Monitor ‚Äî Open infrastructure for monitoring the European environment\nNFDI4Earth ‚Äî National Research Data Infrastructure for Earth System Science\n\nThis project has received funding from the Open-Earth-Monitor Cyberinfrastructure project that is part of European Union's Horizon Europe research and innovation programme under grant 101059548.","category":"section"}]
}
