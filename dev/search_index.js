var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page contains the complete API documentation for YAXArraysToolbox.jl.","category":"section"},{"location":"api/#Basic-Operations","page":"API Reference","title":"Basic Operations","text":"","category":"section"},{"location":"api/#Time-Series-Plotting","page":"API Reference","title":"Time Series Plotting","text":"","category":"section"},{"location":"api/#Spatial-Mapping","page":"API Reference","title":"Spatial Mapping","text":"","category":"section"},{"location":"api/#Temporal-Aggregation","page":"API Reference","title":"Temporal Aggregation","text":"","category":"section"},{"location":"api/#Masking-Functions","page":"API Reference","title":"Masking Functions","text":"","category":"section"},{"location":"api/#Temporal-Masking","page":"API Reference","title":"Temporal Masking","text":"","category":"section"},{"location":"api/#Spatial-Masking","page":"API Reference","title":"Spatial Masking","text":"","category":"section"},{"location":"api/#General-Masking","page":"API Reference","title":"General Masking","text":"","category":"section"},{"location":"api/#Space-for-Time-Analysis","page":"API Reference","title":"Space-for-Time Analysis","text":"","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#YAXArraysToolbox.plot_time","page":"API Reference","title":"YAXArraysToolbox.plot_time","text":"Plot time\n\nThe function allow to plot the time series of a given variables in a cube or all the variables present in a cube. As is expected that cubes contain spatial dimensions the spatial dimensions are collapsed using a function e.g., estimating the mean of the variable using the pixels of a certain area for each time step.\n\n## Arguments:\n\n- ```cube_in``` YAXArray Cube.\n- ```time_axis```: String. Name of the time axis.\n- ```var_axis```: String. Name of the axis containing the variables.\n- ```var```: String or nothing. Name of the variable to be plotted. If nothing all the variables presented in the cube are plotted.\n- ```lat_axis```: String. Name of the latitude axis.\n- ```lon_axis```: String. Name of the longitute axis.\n- ```fun```: String. Name of the function used to collapse the spatial dimensions. It must be \"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", or \"max\".\n- ```plot_type```: String. Name of the plot type. By default: \"lines\". It can also be \"scatter\".\n- ```p```: Float64. in the interval [0,1]. If ```fun=quant``` p is the value of the quantile. \n- ```resolution```: Tuple. Plot resolution. By default ```resolution = (600, 400)```. \n- ```ncol```: Number of plots by column. By default ```ncol = 1```.\n- ```nrow```: Number of plots by row. By default ```ncol = 1```.\n- ```showprog```: Boolean. Progress Bar.\n- ```max_cache```: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\n\n## Examples\n\n```julia\nusing YAXArrays, Zarr, CairoMakie, GeoMakie, Statistics, DimensionalData\n\nmetric = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\n\ncube_in = open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-1x720x1440-2.1.1.zarr\",\n)\n\ncube_in = Cube(cube_in)\ncube_in.Variable\n\ncube_in = cube_in[\n    lon = (-9.0 .. 0.0),\n    lat = (35 .. 40),\n    Ti = (Date(2010) .. Date(2014)),\n    Variable = At([\"leaf_area_index\", \"sensible_heat\"]),\n]\n\n\n\nplot_time(\n    cube_in;\n    time_axis = :Ti,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = \"sensible_heat\",\n    fun = \"median\",\n    p = 0.2,\n    showprog = true,\n    max_cache = \"100MB\",\n)\n\nplot_time(\n    cube_in;\n    time_axis = :Ti,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = nothing,\n    fun = \"median\",\n    resolution = (900, 600),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"100MB\",\n    ncol = 2,\n)\n\nfor i in eachindex(metric)\n    println(metric[i])\n    plot_time(\n        cube_in;\n        time_axis = :Ti,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric[i],\n        p = 0.2,\n        showprog = true,\n        max_cache = \"100MB\",\n    )\nend\n\n```\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.plot_space","page":"API Reference","title":"YAXArraysToolbox.plot_space","text":"Plot Space/Maps\n\nArguments\n\ncube_in: YAXArray Cube.\ntime_axis: String. Name of the time axis.\nvar_axis: String. Name of the axis containing the variables.\nvar: String or nothing. Name of the variable to be plotted. If nothing all the variables presented in the cube are plotted.\nlat_axis: String. Name of the latitude axis.\nlon_axis: String. Name of the longitute axis.\nfun: String. Name of the function used to collapse the spatial dimensions. It must be \"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", or \"max\".\np: Float64. in the interval [0,1]. If fun=quant p is the value of the quantile.\ncolormap: Color Map. By default: colormap = Reverse(:batlow)\ncoastlines: Boolean. Plot coast lines. By default coastlines = false\nresolution: Plot resolution. By default resolution = (800, 300).\nxticklabel_pad: Int. X labels padding. By default xticklabel_pad = 20.\nyticklabel_pad: Int. Y labels padding. By default yticklabel_pad =20.\nncol: Number of plots by column. By default ncol = 1.\nnrow: Number of plots by row. By default ncol = 1.\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\n\nusing YAXArraysToolbox\nusing CairoMakie\nusing Statistics\nusing GeoMakie\nusing YAXArrays\nusing DimensionalData\n\n\ncube_in = open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-1x720x1440-2.1.1.zarr\",\n)\n\ncube_in = Cube(cube_in)\n\n\ncube_in = cube_in[\n    lon = (-9.0 .. 0.0),\n    lat = (35 .. 40),\n    Ti = (Date(2010) .. Date(2014)),\n    Variable = At([\"leaf_area_index\", \"sensible_heat\"]),\n]\n\nplot_space(cube_in; time_axis = :Ti, resolution = (900, 500), xticklabel_pad = 25, yticklabel_pad = 25, var_axis = :Variable, var = \"leaf_area_index\", fun = \"median\")\n\n\nmetric = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\n\nfor i in eachindex(metric)\n    println(metric[i])\n    plot_space(\n        cube_in;\n        time_axis = :Ti,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric[i],\n        p = 0.2,\n        showprog = true,\n        max_cache = \"100MB\",\n    )\nend\n\n\n\nplot_space(\n    cube_in;\n    time_axis = :Ti,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = nothing,\n    fun = \"median\",\n    resolution = (1200, 300),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"100MB\",\n    ncol = 2,\n)\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.aggregate_time","page":"API Reference","title":"YAXArraysToolbox.aggregate_time","text":"Aggregate by time\n\nArguments:\n\ncube_in YAXArray Cube.\ntime_axis: String. Name of the time axis.\nnew_resolution: String. New temporal resolution can be \"day\", \"month\", \"year\".\nnew_time_step: Int64. Time step to be computed in the new time series. e.g. new_resolution=\"day\", new_time_step=8 will compute the function each 8 days. The new time dimension will only contain the days corresponding to the 8th day.\nfun: String. Function to be applied to aggregate the time. It can be \"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\".\np: Float64 in the interval [0,1]. If fun=quant p is the value of the quantile. \nskipMissing: Boolean. Skip missing values when aggregating the data. If all values are missing, NaN is returned.\nskipnan: Boolean. Skip NaN values when aggregating the data. If all values are NaN, NaN is returned.\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\n\nusing YAXArrays, Zarr, DimensionalData, YAXArraysToolbox\n\nesds = open_dataset(\"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\")\nesdc = Cube(esds)\n\n# Estimating the monthly LAI\n\nlai_month = aggregate_time(esdc[Variable = At(\"leaf_area_index\")]; time_axis = :Ti, new_resolution = \"month\", new_time_step=1, fun=\"mean\", p=nothing, skipMissing=true, skipnan=true, showprog=true, max_cache=\"1GB\")\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.masking_time","page":"API Reference","title":"YAXArraysToolbox.masking_time","text":"Masking using time dimension.\n\nThe function implements two methods:\n\nMasking based on a threshold value for one of the variables presented in the cube. e.g., masking the values of all the variables presented in the cube where radiation is lower than X.\nMasking based on the quantile threshold, where the quantile is estimated using the time series for each one of the variables presented in the cube.\n\nThe masked vales are set as NaN.\n\nArguments:\n\ncube_in YAXArray Cube.\ntime_axis: String. Name of the time axis.\nvar_axis: String. Name of the axis containing the variables.\nvar_mask: String or nothing. Name of the variable to be used to mask the other variables. If String val must be an Int64 or Float64 number. If nothing, val must be nothing and p must be a Float64 in the interval [0,1].\nval: Float64 or nothing. The value of the threshold in var_mask to be used to mask all the variables in the cube. If var_mask = nothing then, val=nothing\np: Float64 or nothing. Quantile value used as a threshold to mask the variables.\ncomp: String. Standard comparison operation between the threshold value and each one of the elements. comp Must be one of the following: \"==\", \"!=\" \"<\", \"<=\", \">\", \">=\".\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\nusing YAXArrays, Statistics, Zarr, NetCDF, YAXArraysToolbox\n\nesds = open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\",\n)\nesdc = Cube(esds)\n\nesdc_small = esdc[\n    lon = (-86, -35),\n    lat = (-56, 14),\n    time = (Date(2010), Date(2014)),\n    Variable = [\"leaf_area_index\", \"sensible_heat\", \"potential_evaporation\"],\n]\n\ntest = masking_time(\n    esdc_small;\n    time_axis = \"time\",\n    var_axis = \"Variable\",\n    var_mask = \"leaf_area_index\",\n    val = 0.2,\n    comp = \"<\",\n    showprog = true,\n    max_cache = \"1GB\",\n)\n\nplot_time(esdc_small; time_axis=\"time\", var_axis=\"Variable\", var = \"leaf_area_index\", lat_axis = \"lat\", lon_axis=\"lon\", fun = \"min\")\n\nplot_time(test; time_axis=\"time\", var_axis=\"Variable\", var = \"leaf_area_index\", lat_axis = \"lat\", lon_axis=\"lon\", fun = \"min\")\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.masking_space","page":"API Reference","title":"YAXArraysToolbox.masking_space","text":"Masking using spatial dimension\n\nThe masked vales are set as NaN!!.\n\nArguments:\n\ncube_in YAXArray Cube to be masked.\n\n-mask YAXArray Cube without time dimension and with a single variable to be used as mask. All values equal to NaN or missing will be masked in cubein. The mask will be applied to all the variables and time steps presented in ```cubein```.\n\nlat_axis: String. Name of the latitude axis.\nlon_axis: String. Name of the longitude axis.\nval_mask: NaN or missing. Value present in mask to be used as reference to mask cube_in. Must be NaN or missing.\nshowprog: Boolean. Progress Bar.\nmax_cache: String. Maximum cache to read the data. It must be in MB e.g. \"100MB\" or in GB \"10GB\".\n\nExamples\n\nusing YAXArrays, Zarr, DimensionalData, Test\naxlist = (\n    Dim{:Ti}(range(1, 20, length = 20)),\n    Dim{:x}(range(1, 10, length = 10)),\n    Dim{:y}(range(1, 5, length = 15)),\n    Dim{:Variable}([\"var1\", \"var2\"]),\n    )\n    \n    \n    data = rand(20, 10, 15, 2)\n    \n    \n    ds = YAXArray(axlist, data)\n    \n    axlist = (\n    Dim{:x}(range(1, 10, length = 10)),\n    Dim{:y}(range(1, 5, length = 15)),\n    Dim{:Variable}([\"var1\"]),\n    )\n    \n    \n    data = rand(10, 15, 1)\n    \n    data[3,5,1] = NaN\n    \n    data[1,10,1] = NaN\n    \n    \n    data[9,5,1] = NaN\n    \n    ds_mask = YAXArray(axlist, data)\n    \n    \n    \n    test_cube = masking_space(ds, ds_mask; lat_axis = :x, lon_axis = :y)\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.masking_proc","page":"API Reference","title":"YAXArraysToolbox.masking_proc","text":"Masking processor\n\nArguments:\n\ncube_in_to_mask: YAXArray cube to be masked.\ncube_rsquare: Nothing, or YAXArray cube with the R^2 variable. If set to nothing no mask is applied\nrsquare_thr: Float64. R^2 threshold. All values lower than rsquare_thr are set to NaN\ncube_co_occurrence: Nothing, or YAXArray cube with the co-occurrence variable. If set to nothing no mask is applied.\nco_occurence_thr: Float64. Co-occurence threshold. All values lower than co_occurence_thr are set to NaN\ncube_delta: Nothing, or YAXArray cube with delta variable. If set to nothing no mask is applied.\nminmax_delta: Tuple. Minimum and maximum thresholds of delta variable. Values lower and higher than the thresholds are set to NaN. It is also possible to set any of the thresholds as nothing e.g. (-1, nothing) or (nothing, 1) in these cases only one threshold is applied.\ntime_dim: Nothing, or String. Name of the time dimension. This dimensions needs to be present in all the cubes. If set to nothing no time dimension considered (It can result in slower computation time!). By default time_dim = time\nshowprog: Boolean. Show progress bar. By default showprog = true\n\nOutput:\n\nYAXArray cube masked.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.space4time_proc","page":"API Reference","title":"YAXArraysToolbox.space4time_proc","text":"Space for time processor\n\nArguments:\n\ncube_con : YAXARRAY with the continous variable to be analyized.\n\ncube_classes: YAXARRAY with the discrete classes to be used in the space4time.\n\ntime_axis_name : String or nothing. Name of the time axis on the input cubes. By default time_axis_name = \"time\". if time_axis_name = nothing, not time dimension considered.\n\nlon_axis_name : String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lon\"\n\nlat_axis_name :  String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lat\"\n\nclasses_var_name : String. Name of the Variable containing the discrete classes. By default classes_var_name = \"classes\".\n\nwinsize: Edge size of the moving window on pixels. By default winsize = 5. E.g. winsize = 5 will produce a moving window with 5^2 pixels.\n\nminpxl : Minimum number of pixels in the moving window. By default minpxl = 25. Change accordindly to your winsize parameter.\n\nminDiffPxls: Minimum number pixels in the moving window that must have different compositions. Must be any value in the interval 1 to winsize^2. By default minDiffPxls = 15.\n\nclasses_vec: A string vector with the names of the classes on cube_classes to be used. e.g. from MPI-BGC internal structure classes_vec = [\"Evergreen_Needleleaf_Forests\", \"Evergreen_Broadleaf_Forests\", \"Deciduous_Needleleaf_Forests\", \"Deciduous_Broadleaf_Forests\", \"Mixed_Forests\", \"Closed_Shrublands\", \"Open_Shrublands\", \"Woody_Savannas\", \"Savannas\", \"Grasslands\", \"Permanent_Wetlands\", \"Croplands\", \"Urban_and_Built-up_Lands\", \"Cropland/Natural_Vegetation_Mosaics\", \"Permanent_Snow_and_Ice\", \"Barren\", \"Water_Bodies\"]\nmax_value: Indicates if the scale of the presence of the discrete classes if from 0 to 1 or 0 to 100 if max_value = 100 then the data is re-scaled from 0 to 1. By default max_value = 1\nshowprog: Show progress bar. By default showprog = true\nmax_cache: Size of the cache to allocate temporarily sections of the cubes. By default max_cache = 1e8\n\nOutput:\n\nThe space4time_proc produces a YAXARRAY.Dataset with three cubes:\n\nsummarymovwindow cube has one axis summary_stat, and three variables:\nrsquared:  \ncumulative_variance:\npredicted: Mean prediction of Z for moving window with the real combination of values.\nmetrics_for_classes cube has one axis Values of Z for pure classes, and two variables:\nestimated:\nestimated_error:\nmetricsfortransitions has two axis transitions (all the transitions by pairs between the different classes), and Differences with three variables:\ndelta: delta of the biophysical produced of going from one class the another.\ndelta_error:\ncoocurence:\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.space4time_proc_space","page":"API Reference","title":"YAXArraysToolbox.space4time_proc_space","text":"Space for time processor (space chunks)\n\nArguments:\n\ncube_con : YAXARRAY with the continous variable to be analyized.\n\ncube_classes: YAXARRAY with the discrete classes to be used in the space4time.\n\ntime_axis_name : String or nothing. Name of the time axis on the input cubes. By default time_axis_name = \"time\". if time_axis_name = nothing, not time dimension considered.\n\nlon_axis_name : String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lon\"\n\nlat_axis_name :  String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lat\"\n\nclasses_var_name : String. Name of the Variable containing the discrete classes. By default classes_var_name = \"classes\".\n\nwinsize: Edge size of the moving window on pixels. By default winsize = 5. E.g. winsize = 5 will produce a moving window with 5^2 pixels.\n\nminpxl : Minimum number of pixels in the moving window. By default minpxl = 25. Change accordindly to your winsize parameter.\n\nminDiffPxlspercentage: Percentage of minimum number pixels in the moving window that must have different compositions. Must be any value in the interval 30-100. By default minDiffPxlspercentage = 40\n\nclasses_vec: A string vector with the names of the classes on cube_classes to be used. e.g. from MPI-BGC internal structure classes_vec = [\"Evergreen_Needleleaf_Forests\", \"Evergreen_Broadleaf_Forests\", \"Deciduous_Needleleaf_Forests\", \"Deciduous_Broadleaf_Forests\", \"Mixed_Forests\", \"Closed_Shrublands\", \"Open_Shrublands\", \"Woody_Savannas\", \"Savannas\", \"Grasslands\", \"Permanent_Wetlands\", \"Croplands\", \"Urban_and_Built-up_Lands\", \"Cropland/Natural_Vegetation_Mosaics\", \"Permanent_Snow_and_Ice\", \"Barren\", \"Water_Bodies\"]\nmax_value: Indicates if the scale of the presence of the discrete classes if from 0 to 1 or 0 to 100 if max_value = 100 then the data is re-scaled from 0 to 1. By default max_value = 1\nshowprog: Show progress bar. By default showprog = true\nmax_cache: Size of the cache to allocate temporarily sections of the cubes. By default max_cache = 1e8\n\nOutput:\n\nThe space4time_proc produces a YAXARRAY.Dataset with three cubes:\n\nSummaryStats cube has one axis summary_stat, and three variables:\nrsquared:  \ncumulative_variance:\npredicted:\nmetrics_for_classes cube has one axis Values of Z for pure classes, and two variables:\nestimated:\nestimated_error:\nmetricsfortransitions has two axis transitions (all the transitions by pairs between the different classes), and Differences with three variables:\ndelta:\ndelta_error:\ncoocurence:\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAXArraysToolbox.space4time_proc_old","page":"API Reference","title":"YAXArraysToolbox.space4time_proc_old","text":"Space for time processor\n\nArguments:\n\ncube_con : YAXARRAY with the continous variable to be analyized.\n\ncube_classes: YAXARRAY with the discrete classes to be used in the space4time.\n\ntime_axis_name : String or nothing. Name of the time axis on the input cubes. By default time_axis_name = \"time\". if time_axis_name = nothing, not time dimension considered.\n\nlon_axis_name : String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lon\"\n\nlat_axis_name :  String. Name of the longitude axis on the input cubes. By default lon_axis_name = \"lat\"\n\nclasses_var_name : String. Name of the Variable containing the discrete classes. By default classes_var_name = \"classes\".\n\nwinsize: Edge size of the moving window on pixels. By default winsize = 5. E.g. winsize = 5 will produce a moving window with 5^2 pixels.\n\nminpxl : Minimum number of pixels in the moving window. By default minpxl = 25. Change accordindly to your winsize parameter.\n\nminDiffPxlspercentage: Percentage of minimum number pixels in the moving window that must have different compositions. Must be any value in the interval 30-100. By default minDiffPxlspercentage = 40\n\nclasses_vec: A string vector with the names of the classes on cube_classes to be used. e.g. from MPI-BGC internal structure classes_vec = [\"Evergreen_Needleleaf_Forests\", \"Evergreen_Broadleaf_Forests\", \"Deciduous_Needleleaf_Forests\", \"Deciduous_Broadleaf_Forests\", \"Mixed_Forests\", \"Closed_Shrublands\", \"Open_Shrublands\", \"Woody_Savannas\", \"Savannas\", \"Grasslands\", \"Permanent_Wetlands\", \"Croplands\", \"Urban_and_Built-up_Lands\", \"Cropland/Natural_Vegetation_Mosaics\", \"Permanent_Snow_and_Ice\", \"Barren\", \"Water_Bodies\"]\nmax_value: Indicates if the scale of the presence of the discrete classes if from 0 to 1 or 0 to 100 if max_value = 100 then the data is re-scaled from 0 to 1. By default max_value = 1\nshowprog: Show progress bar. By default showprog = true\nmax_cache: Size of the cache to allocate temporarily sections of the cubes. By default max_cache = 1e8\n\nOutput:\n\nThe space4time_proc produces a YAXARRAY.Dataset with three cubes:\n\nSummaryStats cube has one axis summary_stat, and three variables:\nrsquared:  \ncumulative_variance:\npredicted: Mean prediction of Z for moving window with the real combination of values.\nmetrics_for_classes cube has one axis Values of Z for pure classes, and two variables:\nestimated:\nestimated_error:\nmetricsfortransitions has two axis transitions (all the transitions by pairs between the different classes), and Differences with three variables:\ndelta: delta of the biophysical produced of going from one class the another.\ndelta_error:\ncoocurence:\n\n\n\n\n\n\n\n","category":"function"},{"location":"tutorials/basic_operations/#basic_operations","page":"Basic Operations","title":"Basic Operations","text":"Getting started with YAXArraysToolbox.jl\n\nAuthor: Daniel E. Pabon-Moreno","category":"section"},{"location":"tutorials/basic_operations/#Introduction","page":"Basic Operations","title":"Introduction","text":"This tutorial demonstrates the core functionality of YAXArraysToolbox.jl for working with spatio-temporal data cubes. We'll cover:\n\nLoading data from the Earth System Data Cube\nPlotting time series with plot_time\nCreating spatial maps with plot_space\nAggregating data over time with aggregate_time","category":"section"},{"location":"tutorials/basic_operations/#Setup","page":"Basic Operations","title":"Setup","text":"First, load the required packages:\n\nusing Pkg\nPkg.instantiate()\nusing YAXArrays\nPkg.add(url=\"https://github.com/dpabon/YAXArraysToolbox.jl\")\nusing YAXArraysToolbox\nusing CairoMakie\nusing GeoMakie\nusing Statistics\nusing Zarr\nusing Dates\nusing PythonCall\nusing DimensionalData","category":"section"},{"location":"tutorials/basic_operations/#Loading-Data","page":"Basic Operations","title":"Loading Data","text":"We'll use the Earth System Data Cube (ESDC), a analysis-ready data cube containing many climate and Earth observation variables.\n\nesdc = open_dataset(\"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\")\nesdc = Cube(esdc)\nesdc","category":"section"},{"location":"tutorials/basic_operations/#Basic-Functions","page":"Basic Operations","title":"Basic Functions","text":"","category":"section"},{"location":"tutorials/basic_operations/#Plot-Time","page":"Basic Operations","title":"Plot Time","text":"The plot_time function creates time series plots by collapsing spatial dimensions using a specified statistic (mean, median, std, etc.).\n\n:::","category":"section"},{"location":"tutorials/basic_operations/#Subsetting-the-Data","page":"Basic Operations","title":"Subsetting the Data","text":"Let's select a region (South America) and time period:\n\ncube_to_plot = esdc[\n    lon = -86 .. -35,\n    lat = -56 .. 14,\n    time = Date(2010) ..  Date(2014),\n    Variable = At(\"leaf_area_index\", \"sensible_heat\"),\n]\ncube_to_plot","category":"section"},{"location":"tutorials/basic_operations/#Plotting-All-Variables","page":"Basic Operations","title":"Plotting All Variables","text":"By default, plot_time plots all variables in the cube:\n\nplot_time(\n    cube_to_plot;\n    time_axis = :time,\n    var_axis = :Variables,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = nothing,\n    fun = \"std\",\n    resolution = (900, 600),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"1GB\",\n    ncol = 1,\n    nrow = 2\n)","category":"section"},{"location":"tutorials/basic_operations/#Plotting-a-Single-Variable","page":"Basic Operations","title":"Plotting a Single Variable","text":"You can also plot a specific variable:\n\nplot_time(\n    cube_to_plot;\n    time_axis = :time,\n    var_axis = :Variable,\n    lon_axis = :lon,\n    lat_axis = :lat,\n    var = \"sensible_heat\",\n    fun = \"std\",\n    resolution = (900, 600),\n    p = 0.2,\n    showprog = true,\n    max_cache = \"1GB\",\n    ncol = 1,\n    nrow = 2\n)","category":"section"},{"location":"tutorials/basic_operations/#Available-Statistics","page":"Basic Operations","title":"Available Statistics","text":"The fun parameter supports multiple statistics:\n\nmetrics = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\nfor metric in metrics\n    fig = plot_time(\n        cube_to_plot;\n        time_axis = :time,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric,\n        resolution = (900, 600),\n        p = 0.2,\n        showprog = true,\n        max_cache = \"1GB\",\n        ncol = 1,\n        nrow = 2\n    )\n    display(fig)\nend","category":"section"},{"location":"tutorials/basic_operations/#Plot-Space","page":"Basic Operations","title":"Plot Space","text":"The plot_space function creates spatial maps by collapsing the time dimension.\n\n#| output: false\n@doc plot_space","category":"section"},{"location":"tutorials/basic_operations/#Single-Variable-Map","page":"Basic Operations","title":"Single Variable Map","text":"cube_to_plot = esdc[\n    lon = -86 .. -34,\n    lat = -56 .. 14,\n    time = Date(2010) .. Date(2014),\n    Variable = At(\"leaf_area_index\", \"sensible_heat\"),\n]\n\nplot_space(\n    cube_to_plot;\n    time_axis = :time,\n    resolution = (900, 600),\n    var_axis = :Variable,\n    var = \"leaf_area_index\",\n    fun = \"median\"\n)","category":"section"},{"location":"tutorials/basic_operations/#Multiple-Variables","page":"Basic Operations","title":"Multiple Variables","text":"Set var = nothing to plot all variables:\n\nplot_space(\n    cube_to_plot;\n    time_axis = :time,\n    resolution = (900, 600),\n    var_axis = :Variables,\n    var = nothing,\n    ncol = 2,\n    nrow = 1,\n    fun = \"median\"\n)","category":"section"},{"location":"tutorials/basic_operations/#All-Statistics-for-a-Variable","page":"Basic Operations","title":"All Statistics for a Variable","text":"metrics = [\"median\", \"mean\", \"std\", \"var\", \"sum\", \"quant\", \"min\", \"max\"]\n\nfor metric in metrics\n    fig = plot_space(\n        cube_to_plot;\n        time_axis = :time,\n        var_axis = :Variable,\n        lon_axis = :lon,\n        lat_axis = :lat,\n        var = \"sensible_heat\",\n        fun = metric,\n        p = 0.2,\n        showprog = true,\n        max_cache = \"100MB\"\n    )\n    display(fig)\nend","category":"section"},{"location":"tutorials/basic_operations/#Aggregate-by-Time","page":"Basic Operations","title":"Aggregate by Time","text":"The aggregate_time function allows you to aggregate data to different temporal resolutions (e.g., daily ‚Üí monthly).\n\n#| output: false\n@doc aggregate_time","category":"section"},{"location":"tutorials/basic_operations/#Monthly-Aggregation","page":"Basic Operations","title":"Monthly Aggregation","text":"Let's compute the monthly mean of the Leaf Area Index:\n\nlai_month = aggregate_time(\n    esdc[Variable = At(\"leaf_area_index\")];\n    time_axis = :time,\n    new_resolution = \"month\",\n    new_time_step = 1,\n    fun = \"mean\",\n    p = nothing,\n    skipMissing = true,\n    skipnan = true,\n    showprog = true,\n    max_cache = \"1GB\"\n)\nlai_month\n\nCheck the new time axis:\n\nlookup(lai_month, :Ti)\n\nThe original 8-day temporal resolution has been aggregated to monthly values. The time axis now contains 480 values (one per month) instead of the original ~1800+ values.","category":"section"},{"location":"tutorials/basic_operations/#Summary","page":"Basic Operations","title":"Summary","text":"Function Purpose Key Parameters\nplot_time Time series plot fun, var, time_axis\nplot_space Spatial map fun, var, time_axis\naggregate_time Temporal aggregation new_resolution, fun","category":"section"},{"location":"tutorials/basic_operations/#Next-Steps","page":"Basic Operations","title":"Next Steps","text":"Learn about the Space4Time methodology","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#space4time","page":"Space-for-Time Method","title":"Space-for-Time Method","text":"Proof of Concept\n\nAuthor: Daniel E. Pabon-Moreno","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Introduction","page":"Space-for-Time Method","title":"Introduction","text":"Land use changes have significant consequences on the Earth system's energy budget. For example, deforestation of tropical rainforests to expand agricultural areas profoundly impacts carbon and water cycles at local, regional, and global scales.\n\nAssessing the impact of land use changes on climate biophysical variables is increasingly important in the context of global warming and climate change. The space-for-time method uses local vegetation contrasts to disentangle the effects of land use changes on biophysical variables.\n\nThis notebook explains the theoretical approach and demonstrates the technical implementation.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Setup","page":"Space-for-Time Method","title":"Setup","text":"using Pkg\nPkg.add(url=\"https://github.com/JuliaStats/GLM.jl\", rev=\"f4047d4930957bc5317fd4d0b73f197383a4ee4a\")\nPkg.add(url = \"https://github.com/dpabon/YAXArraysToolbox.jl\")\nusing SkipNan\nusing YAXArraysToolbox\nusing YAXArrays\nusing Zarr\nusing CairoMakie\nusing GeoMakie\nusing Random\nusing NeutralLandscapes\nusing TiledViews\nusing DimensionalData\nusing Statistics\n\n# Set temporary directory for YAXArrays\nYAXArrays.YAXdir(\"/tmp/YAXA_tmp\")\n\n# Activate CairoMakie for plotting\nCairoMakie.activate!()","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#The-Space-for-Time-Method","page":"Space-for-Time Method","title":"The Space-for-Time Method","text":"","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Concept","page":"Space-for-Time Method","title":"Concept","text":"The space-for-time method relies on the assumption that spatial variability in land cover within a local area can serve as a proxy for temporal changes in land cover. By analyzing how biophysical variables (like Land Surface Temperature) vary across different land cover types within a moving window, we can estimate the impact of land cover transitions.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Key-Steps","page":"Space-for-Time Method","title":"Key Steps","text":"Define a moving window over the study area\nWithin each window, analyze the relationship between land cover composition and the target variable\nUse regression to estimate the contribution of each land cover type\nCalculate the expected change when transitioning between land cover types\n\nflowchart TD\n    A[Land Cover Map] --> B[Moving Window]\n    C[Biophysical Variable] --> B\n    B --> D[Local Regression]\n    D --> E[Land Cover Coefficients]\n    E --> F[Transition Effects]","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Generating-Synthetic-Data","page":"Space-for-Time Method","title":"Generating Synthetic Data","text":"To demonstrate the method, we'll create synthetic land cover and temperature data.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Create-a-Land-Cover-Map","page":"Space-for-Time Method","title":"Create a Land Cover Map","text":"We'll generate a 10 km √ó 10 km land cover map where 1 pixel = 1 meter:\n\nedge = 1000\nsize_tile = (edge, edge)\n\nGenerate spatially autocorrelated patterns:\n\nRandom.seed!(232323)\nspatial_auto = 0.9\nmidpoint_sim = rand(MidpointDisplacement(spatial_auto), size_tile)\nheatmap(midpoint_sim)\n\nClassify into 3 land cover classes:\n\nn_classes = 3\nclasses_dist = NeutralLandscapes.classify(midpoint_sim, ones(n_classes))\n\nheatmap(classes_dist)","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Assign-LST-Values-per-Class","page":"Space-for-Time Method","title":"Assign LST Values per Class","text":"We define a constant Land Surface Temperature (LST) for each class:\n\n# LST values per class (¬∞C)\nclass_1_lst = 20.0  # e.g., Forest\nclass_2_lst = 22.0  # e.g., Grassland\nclass_3_lst = 23.8  # e.g., Cropland\n\nall_lst = (class_1_lst, class_2_lst, class_3_lst)\n\n# Create LST map\nlst = fill(NaN, size_tile)\n\nfor i in eachindex(all_lst)\n    lst[findall(==(i), classes_dist)] .= all_lst[i]\nend","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Using-altitude-as-a-counfounding-factor","page":"Space-for-Time Method","title":"Using altitude as a counfounding factor","text":"Random.seed!(87)\nspatial_auto = 0.9\nmidpoint_sim = rand(MidpointDisplacement(spatial_auto), size_tile)\nheatmap(midpoint_sim)\n\naltitude = midpoint_sim * 1000\naltitude\n\nWe will prescribe a LST adiabatic lapse rate of 9.8 per 1000 meters\n\nheatmap(lst)\n\nlst_altitude_corrected = lst .- (altitude .* 9.8 / 1000)\nheatmap(lst_altitude_corrected)\n\nscatter(vec(altitude), vec(lst_altitude_corrected))","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Spatial-Resampling","page":"Space-for-Time Method","title":"Spatial Resampling","text":"Land cover maps typically have coarser resolution than 1 meter. We'll aggregate to a new spatial resolution and estimate the frequency of each class per pixel.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Resample-Land-Cover-Classes","page":"Space-for-Time Method","title":"Resample Land Cover Classes","text":"\nsize_pixel_new = 20\n\n# Each new pixel contains 10√ó10 = 100 original pixels\n# Use TiledView to create views of each new pixel\na = TiledView(classes_dist, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false, pad_value = NaN32)\n\n# Array for resampled class frequencies\nnew_res_array_classes = fill(0.0, (size_pixel_new, size_pixel_new, n_classes))\n\nfor i in 1:size_pixel_new\n    for j in 1:size_pixel_new\n        for c in 1:n_classes\n            new_res_array_classes[i, j, c] = count(==(c), a[:, :, i, j]) / (size_pixel_new^2)\n        end\n    end\nend\n\nVisualize the class frequencies:\n\nfor i in 1:n_classes\n    fig = Figure()\n    ax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Class $i\")\n    temp = heatmap!(new_res_array_classes[:, :, i], colormap = Reverse(:bamako))\n    Colorbar(fig[1, 2], temp, label = \"Occurrence\")\n    display(fig)\nend","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Resample-Altitude","page":"Space-for-Time Method","title":"Resample Altitude","text":"For the altitude we will create a dataset with two variables. altitude_mean, altitude_sd.\n\na = TiledView(altitude, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false)\n\nnew_res_array_altitude = fill(NaN, (size_pixel_new, size_pixel_new, 2))\n\nfor i in 1:size_pixel_new\n    for j in 1:size_pixel_new\n        new_res_array_altitude[i, j, 1] = mean(a[:, :, i, j])\n        new_res_array_altitude[i, j, 2] = std(a[:, :, i, j])\n    end\nend\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Altitude Resampled\")\ntemp = heatmap!(new_res_array_altitude[:, :, 1], colormap = :lajolla)\nColorbar(fig[1, 2], temp, label = \"Altitude (m) mean\")\nfig\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"Altitude Resampled\")\ntemp = heatmap!(new_res_array_altitude[:, :, 2], colormap = :lajolla)\nColorbar(fig[1, 2], temp, label = \"Altitude (m) std\")\nfig","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Resample-LST","page":"Space-for-Time Method","title":"Resample LST","text":"a = TiledView(lst_altitude_corrected, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false)\n\nnew_res_array_lst = fill(NaN, (size_pixel_new, size_pixel_new))\n\nfor i in 1:size_pixel_new\n    for j in 1:size_pixel_new\n        new_res_array_lst[i, j] = mean(a[:, :, i, j])\n    end\nend\n\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"x\", ylabel = \"y\", title = \"LST Resampled\")\ntemp = heatmap!(new_res_array_lst[:, :], colormap = :lajolla)\nColorbar(fig[1, 2], temp, label = \"LST (¬∞C)\")\nfig","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Organizing-Data-as-YAXArrays","page":"Space-for-Time Method","title":"Organizing Data as YAXArrays","text":"","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Land-Cover-Cube","page":"Space-for-Time Method","title":"Land Cover Cube","text":"axlist = (\n   lon(1:size(new_res_array_classes, 1)),\n    lat(1:size(new_res_array_classes, 2)),\n    Variables([\"class$i\" for i in 1:n_classes])\n)\n\nlcc_cube = YAXArray(axlist, new_res_array_classes)\nlcc_cube","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Altitude-Cube","page":"Space-for-Time Method","title":"Altitude Cube","text":"axlist = (\n   lon(1:size(new_res_array_classes, 1)),\n    lat(1:size(new_res_array_classes, 2)),\n    Variables([\"altitude_mean\", \"altitude_sd\"])\n)\n\naltitude_cube = YAXArray(axlist, new_res_array_altitude)","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#LST-Cube","page":"Space-for-Time Method","title":"LST Cube","text":"axlist_lst = (\n    lon(1:size(new_res_array_lst, 1)),\n    lat(1:size(new_res_array_lst, 2))\n)\n\nlst_cube = YAXArray(axlist_lst, new_res_array_lst)\nlst_cube","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Running-Space4Time-Analysis","page":"Space-for-Time Method","title":"Running Space4Time Analysis","text":"Now we can use the space4time_proc function from YAXArraysToolbox:\n\n# Run the analysis\nresults = space4time_proc(\n    lst_cube,\n    lcc_cube,\n    altitude_cube;\n    time_axis_name = nothing,\n    altitude_var_name = :Variables,\n    altitude_vec = [\"altitude_mean\", \"altitude_sd\"],\n    classes_var_name = :Variables,\n    classes_vec = [\"class1\", \"class2\", \"class3\"],\n    winsize = 5,\n    minpxl = 0,\n    minDiffPxls = 0,\n    max_value = 1,\n    showprog = true\n)","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Interpreting-Results","page":"Space-for-Time Method","title":"Interpreting Results","text":"The space4time analysis returns:\n\nCoefficients: The estimated effect of each land cover class on the target variable\nR¬≤: Goodness of fit for each moving window\nTransition effects: Expected change when converting from one class to another","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Filtering-the-results-using-R2-and-co-occurrence","page":"Space-for-Time Method","title":"Filtering the results using R^2 and co-occurrence","text":"metrics_transitions_cube = results.metrics_for_transitions\n\nmetrics_transitions_cube[differences = At(\"delta\")].data\n\nmasking_without_delta = masking_proc(results.metrics_for_transitions;\ncube_rsquared = results.summary_mov_window[summary_stat = At(\"rsquared_adjusted\")], rsquared_thr = 0.2,\ncube_co_occurrence = results.metrics_for_transitions[Differences = At(\"coocurence\")], co_occurence_thr = 0.5,\ncube_delta = nothing, time_dim = nothing, showprog = true)","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Expected-Results","page":"Space-for-Time Method","title":"Expected Results","text":"Given our synthetic data:\n\nTransition Expected ŒîT (¬∞C)\nClass 1 ‚Üí Class 2 +2.0\nClass 1 ‚Üí Class 3 +3.8\nClass 2 ‚Üí Class 3 +1.8\n\nThese values represent the warming effect of converting from cooler (forested) to warmer (agricultural) land cover types.","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Plotting-the-results","page":"Space-for-Time Method","title":"Plotting the results","text":"First we will compared the distribution of the delta values vs the LST defined at the beggining for discrete class.\n\ndelta_1_org = abs(class_1_lst - class_2_lst)\ndelta_2_org = abs(class_1_lst - class_3_lst)\ndelta_3_org = abs(class_2_lst - class_3_lst)\n\nvec_delta_orig = Array{Float64}(reshape(results.metrics_for_transitions[differences = At(\"delta\")].data, (size_pixel_new^2 * n_classes)))\n\nvec_delta_plot = vec_delta_orig[findall(!isnan, vec_delta_orig)]\n\nvec_index = repeat(1:n_classes, outer = (size_pixel_new^2*n_classes))\n\nvec_index = vec_index[findall(!isnan, vec_delta_orig)]\n\ntransitions = lookup(masking_without_delta, :transitions)\nfig = Figure()\nax = Axis(fig[1,1], xticks = (1:length(transitions), transitions))\ntemp = scatter!(ax, vec_index, vec_delta_plot)\ntemp2 = scatter!(ax, [i + 0.1 for i in 1:n_classes], [delta_1_org, delta_2_org, delta_3_org], marker = :diamond, color = :red)\nLegend(fig[1, 2],\n    [temp, temp2],\n    [\"Results Space4time\", \"Original Delta\"])\nfig","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Summary","page":"Space-for-Time Method","title":"Summary","text":"The space-for-time method provides a powerful approach to:\n\nEstimate land cover change impacts without long time series\nLeverage spatial variability as a proxy for temporal change\nQuantify biophysical effects of land use transitions","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#Next-Steps","page":"Space-for-Time Method","title":"Next Steps","text":"","category":"section"},{"location":"tutorials/space4time_proof_of_concept/#References","page":"Space-for-Time Method","title":"References","text":"Duveiller, G., et al. (2018). The mark of vegetation change on Earth's surface energy balance. Nature Communications.\nLi, Y., et al. (2015). Local cooling and warming effects of forests based on satellite observations. Nature Communications.","category":"section"},{"location":"#YAXArraysToolbox.jl","page":"Home","title":"YAXArraysToolbox.jl","text":"High-performance spatio-temporal analysis for Earth System data cubes","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"YAXArraysToolbox.jl is a Julia package that extends YAXArrays.jl with high-level functions for analyzing spatio-temporal data cubes.\n\nnote: Why YAXArraysToolbox?\nBecause laziness is not only good when reading big data ‚Äî it should also apply to common analysis tasks!","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Feature Description\nüìà Time Series Plotting Visualize temporal evolution with spatial aggregation\nüó∫Ô∏è Spatial Mapping Create maps with temporal aggregation\n‚è±Ô∏è Time Aggregation Resample to monthly, yearly, or custom periods\nüîÑ Space-for-Time Analysis Estimate land cover change impacts\nüò∑ Masking Flexible spatial, temporal, and altitude masking","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/dpabon/YAXArraysToolbox.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using YAXArraysToolbox\nusing YAXArrays\nusing CairoMakie\nusing Dates\n\n# Load Earth System Data Cube\nesdc = Cube(open_dataset(\n    \"https://s3.bgc-jena.mpg.de:9000/esdl-esdc-v2.1.1/esdc-8d-0.25deg-184x90x90-2.1.1.zarr\"\n))\n\n# Select region and variables\ncube = esdc[\n    lon = -10 .. 0,\n    lat = 35 .. 45,\n    time = Date(2010) .. Date(2012),\n    Variable = At(\"leaf_area_index\")\n]\n\n# Plot time series (spatial mean)\nplot_time(cube; fun=\"mean\")\n\n# Create spatial map (temporal median)\nplot_space(cube; fun=\"median\")\n\n# Aggregate to monthly resolution\nmonthly = aggregate_time(cube; new_resolution=\"month\", fun=\"mean\")","category":"section"},{"location":"#Main-Functions","page":"Home","title":"Main Functions","text":"","category":"section"},{"location":"#Basic-Operations","page":"Home","title":"Basic Operations","text":"# Time series visualization\nplot_time(cube; fun=\"mean\", var=\"temperature\")\n\n# Spatial mapping  \nplot_space(cube; fun=\"median\", var=\"lai\")\n\n# Temporal aggregation\naggregate_time(cube; new_resolution=\"month\", fun=\"mean\")","category":"section"},{"location":"#Masking","page":"Home","title":"Masking","text":"# Spatial masking\nmasking_space(cube, mask_cube; threshold=0.5)\n\n# Temporal masking\nmasking_time(cube; start_date=Date(2010), end_date=Date(2015))","category":"section"},{"location":"#Spatio-Temporal-Analysis","page":"Home","title":"Spatio-Temporal Analysis","text":"# Space-for-time analysis\nspace4time_proc(climate_cube, landcover_cube, class_list)","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"Get started with our tutorials:\n\nBasic Operations: Learn plot_time, plot_space, and aggregate_time\nSpace-for-Time Method: Understand and apply the space4time methodology","category":"section"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"YAXArraysToolbox\n‚îú‚îÄ‚îÄ Basic Operations\n‚îÇ   ‚îú‚îÄ‚îÄ plot_time\n‚îÇ   ‚îú‚îÄ‚îÄ plot_space\n‚îÇ   ‚îî‚îÄ‚îÄ aggregate_time\n‚îú‚îÄ‚îÄ Masking\n‚îÇ   ‚îú‚îÄ‚îÄ masking_time\n‚îÇ   ‚îú‚îÄ‚îÄ masking_space\n‚îÇ   ‚îî‚îÄ‚îÄ masking_altitude\n‚îî‚îÄ‚îÄ Spatio-Temporal Analysis\n    ‚îî‚îÄ‚îÄ space4time_proc","category":"section"},{"location":"#Dependencies","page":"Home","title":"Dependencies","text":"YAXArraysToolbox builds on these excellent packages:\n\nYAXArrays.jl - Data cube handling\nCairoMakie.jl - Plotting\nGeoMakie.jl - Geographic plotting","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use YAXArraysToolbox in your research, please cite:\n\n(Image: DOI)","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"This project was funded by:\n\nOpen-Earth-Monitor\nNFDI4Earth","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT License","category":"section"}]
}
