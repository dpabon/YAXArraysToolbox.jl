---
title: "Space-for-Time Method"
engine: julia
subtitle: "Proof of Concept"
author: "Daniel E. Pabon-Moreno"
date: last-modified
format:
  html:
    code-fold: false
    toc: true
    toc-depth: 3
execute:
  eval: false
  echo: true
---

## Introduction

Land use changes have significant consequences on the Earth system's energy budget. For example, deforestation of tropical rainforests to expand agricultural areas profoundly impacts carbon and water cycles at local, regional, and global scales.

Assessing the impact of land use changes on climate biophysical variables is increasingly important in the context of global warming and climate change. The **space-for-time method** uses local vegetation contrasts to disentangle the effects of land use changes on biophysical variables.

This notebook explains the theoretical approach and demonstrates the technical implementation.

## Setup

```{julia}
using Pkg
Pkg.develop(url = "https://github.com/dpabon/YAXArraysToolbox.jl")
using YAXArraysToolbox
using YAXArrays
using Zarr
using CairoMakie
using GeoMakie
using Random
using NeutralLandscapes
using TiledViews
using DimensionalData
using Statistics
```

```{julia}
# Set temporary directory for YAXArrays
YAXArrays.YAXdir("/tmp/YAXA_tmp")

# Activate CairoMakie for plotting
CairoMakie.activate!()
```

## The Space-for-Time Method

### Concept

The space-for-time method relies on the assumption that **spatial variability** in land cover within a local area can serve as a proxy for **temporal changes** in land cover. By analyzing how biophysical variables (like Land Surface Temperature) vary across different land cover types within a moving window, we can estimate the impact of land cover transitions.

### Key Steps

1. Define a moving window over the study area
2. Within each window, analyze the relationship between land cover composition and the target variable
3. Use regression to estimate the contribution of each land cover type
4. Calculate the expected change when transitioning between land cover types

```{mermaid}
flowchart TD
    A[Land Cover Map] --> B[Moving Window]
    C[Biophysical Variable] --> B
    B --> D[Local Regression]
    D --> E[Land Cover Coefficients]
    E --> F[Transition Effects]
```

## Generating Synthetic Data

To demonstrate the method, we'll create synthetic land cover and temperature data.

### Create a Land Cover Map

We'll generate a 10 km × 10 km land cover map where 1 pixel = 1 meter:

```{julia}
edge = 1000
size_tile = (edge, edge)
```

Generate spatially autocorrelated patterns:

```{julia}
Random.seed!(232323)
spatial_auto = 0.9
midpoint_sim = rand(MidpointDisplacement(spatial_auto), size_tile)
heatmap(midpoint_sim)
```

Classify into 3 land cover classes:

```{julia}
n_classes = 3
classes_dist = NeutralLandscapes.classify(midpoint_sim, ones(n_classes))
```

```{julia}
heatmap(classes_dist)
```

### Assign LST Values per Class

We define a constant Land Surface Temperature (LST) for each class:

```{julia}
# LST values per class (°C)
class_1_lst = 20.0  # e.g., Forest
class_2_lst = 22.0  # e.g., Grassland
class_3_lst = 23.8  # e.g., Cropland

all_lst = (class_1_lst, class_2_lst, class_3_lst)

# Create LST map
lst = fill(NaN, size_tile)

for i in eachindex(all_lst)
    lst[findall(==(i), classes_dist)] .= all_lst[i]
end
```

### Using altitude as a counfounding factor

```{julia}
Random.seed!(87)
spatial_auto = 0.9
midpoint_sim = rand(MidpointDisplacement(spatial_auto), size_tile)
heatmap(midpoint_sim)
```

```{julia}
altitude = midpoint_sim * 1000
altitude
```

We will prescribe a LST adiabatic lapse rate of 9.8 per 1000 meters

```{julia}
heatmap(lst)
```

```{julia}
lst_altitude_corrected = lst .- (altitude .* 9.8 / 1000)
heatmap(lst_altitude_corrected)
```

```{julia}
scatter(vec(altitude), vec(lst_altitude_corrected))
```

## Spatial Resampling

Land cover maps typically have coarser resolution than 1 meter. We'll aggregate to a new spatial resolution and estimate the frequency of each class per pixel.

### Resample Land Cover Classes

```{julia}

size_pixel_new = 20

# Each new pixel contains 10×10 = 100 original pixels
# Use TiledView to create views of each new pixel
a = TiledView(classes_dist, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false, pad_value = NaN32)

# Array for resampled class frequencies
new_res_array_classes = fill(0.0, (size_pixel_new, size_pixel_new, n_classes))

for i in 1:size_pixel_new
    for j in 1:size_pixel_new
        for c in 1:n_classes
            new_res_array_classes[i, j, c] = count(==(c), a[:, :, i, j]) / (size_pixel_new^2)
        end
    end
end
```

Visualize the class frequencies:

```{julia}
for i in 1:n_classes
    fig = Figure()
    ax = Axis(fig[1, 1]; xlabel = "x", ylabel = "y", title = "Class $i")
    temp = heatmap!(new_res_array_classes[:, :, i], colormap = Reverse(:bamako))
    Colorbar(fig[1, 2], temp, label = "Occurrence")
    display(fig)
end
```

### Resample Altitude

For the altitude we will create a dataset with two variables. ```altitude_mean, altitude_sd```.

```{julia}
a = TiledView(altitude, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false)

new_res_array_altitude = fill(NaN, (size_pixel_new, size_pixel_new, 2))

for i in 1:size_pixel_new
    for j in 1:size_pixel_new
        new_res_array_altitude[i, j, 1] = mean(a[:, :, i, j])
        new_res_array_altitude[i, j, 2] = std(a[:, :, i, j])
    end
end
```

```{julia}
fig = Figure()
ax = Axis(fig[1, 1]; xlabel = "x", ylabel = "y", title = "Altitude Resampled")
temp = heatmap!(new_res_array_altitude[:, :, 1], colormap = :lajolla)
Colorbar(fig[1, 2], temp, label = "Altitude (m) mean")
fig
```

```{julia}
fig = Figure()
ax = Axis(fig[1, 1]; xlabel = "x", ylabel = "y", title = "Altitude Resampled")
temp = heatmap!(new_res_array_altitude[:, :, 2], colormap = :lajolla)
Colorbar(fig[1, 2], temp, label = "Altitude (m) std")
fig
```


### Resample LST

```{julia}
a = TiledView(lst_altitude_corrected, (size_pixel_new, size_pixel_new), (0, 0); keep_center = false)

new_res_array_lst = fill(NaN, (size_pixel_new, size_pixel_new))

for i in 1:size_pixel_new
    for j in 1:size_pixel_new
        new_res_array_lst[i, j] = mean(a[:, :, i, j])
    end
end
```

```{julia}
fig = Figure()
ax = Axis(fig[1, 1]; xlabel = "x", ylabel = "y", title = "LST Resampled")
temp = heatmap!(new_res_array_lst[:, :], colormap = :lajolla)
Colorbar(fig[1, 2], temp, label = "LST (°C)")
fig
```

## Organizing Data as YAXArrays

### Land Cover Cube

```{julia}
axlist = (
   lon(1:size(new_res_array_classes, 1)),
    lat(1:size(new_res_array_classes, 2)),
    Variables(["class$i" for i in 1:n_classes])
)

lcc_cube = YAXArray(axlist, new_res_array_classes)
lcc_cube
```

## Altitude Cube

```{julia}
axlist = (
   lon(1:size(new_res_array_classes, 1)),
    lat(1:size(new_res_array_classes, 2)),
    Variables(["altitude_mean", "altitude_sd"])
)

altitude_cube = YAXArray(axlist, new_res_array_altitude)
```


### LST Cube

```{julia}
axlist_lst = (
    lon(1:size(new_res_array_lst, 1)),
    lat(1:size(new_res_array_lst, 2))
)

lst_cube = YAXArray(axlist_lst, new_res_array_lst)
lst_cube
```

## Running Space4Time Analysis

Now we can use the `space4time_proc` function from YAXArraysToolbox:


```{julia}
# Run the analysis
results = space4time_proc(
    lst_cube,
    lcc_cube,
    altitude_cube;
    time_axis_name = nothing,
    altitude_var_name = :Variables,
    altitude_vec = ["altitude_mean", "altitude_sd"],
    classes_var_name = :Variables,
    classes_vec = ["class1", "class2", "class3"],
    winsize = 5,
    minpxl = 0,
    minDiffPxls = 0,
    max_value = 1,
    showprog = true
)
```

## Interpreting Results

The space4time analysis returns:

1. **Coefficients**: The estimated effect of each land cover class on the target variable
2. **R²**: Goodness of fit for each moving window
3. **Transition effects**: Expected change when converting from one class to another

## Filtering the results using $R^2$ and co-occurrence

```{julia}
metrics_transitions_cube = results.metrics_for_transitions
```

```{julia}
masking_without_delta = masking_proc(results.metrics_for_transitions;
cube_rsquared = results.summary_stats[summary_stat = At("rsquared_adjusted")], rsquared_thr = 0.2,
cube_co_occurrence = results.metrics_for_transitions[Differences = At("coocurence")], co_occurence_thr = 0.5,
cube_delta = nothing, time_dim = nothing, showprog = true)
```

### Expected Results

Given our synthetic data:

| Transition | Expected ΔT (°C) |
|------------|------------------|
| Class 1 → Class 2 | +2.0 |
| Class 1 → Class 3 | +3.8 |
| Class 2 → Class 3 | +1.8 |

These values represent the warming effect of converting from cooler (forested) to warmer (agricultural) land cover types.

## Plotting the results

First we will compared the distribution of the delta values vs the LST defined at the beggining for discrete class.

```{julia}
delta_1_org = abs(class_1_lst - class_2_lst)
delta_2_org = abs(class_1_lst - class_3_lst)
delta_3_org = abs(class_2_lst - class_3_lst)
```

```{julia}
vec_delta_orig = Array{Float64}(reshape(results.metrics_for_transitions[differences = At("delta")].data, (Int(edge/size_pixel_new)^2 * n_classes)))

vec_delta_plot = vec_delta_orig[findall(!isnan, vec_delta_orig)]

vec_index = repeat(1:n_classes, outer = (Int(edge/size_pixel_new)^2*n_classes))

vec_index = vec_index[findall(!isnan, vec_delta_orig)]
```

```{julia}
transitions = getAxis("transitions", masking_without_delta)
fig = Figure()
ax = Axis(fig[1,1], xticks = (1:length(transitions), transitions))
temp = boxplot!(ax, vec_index, vec_delta_plot)
temp2 = scatter!(ax, [i + 0.1 for i in 1:n_classes], [delta_1_org, delta_2_org, delta_3_org], marker = :diamond, color = :red)
Legend(fig[1, 2],
    [temp, temp2],
    ["Results Space4time", "Original Delta"])
fig
```

## Summary

The space-for-time method provides a powerful approach to:

- Estimate land cover change impacts without long time series
- Leverage spatial variability as a proxy for temporal change
- Quantify biophysical effects of land use transitions

## Next Steps

- Apply to real data: [LST Changes in Africa](lst_changes_africa.qmd)
- Learn about cross-validation: [Spatio-temporal Folds](spacetime_folds.qmd)

## References

- Duveiller, G., et al. (2018). The mark of vegetation change on Earth's surface energy balance. *Nature Communications*.
- Li, Y., et al. (2015). Local cooling and warming effects of forests based on satellite observations. *Nature Communications*.
